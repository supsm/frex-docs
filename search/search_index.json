{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"frex docs generated from frex","title":"frex docs"},{"location":"#frex-docs","text":"generated from frex","title":"frex docs"},{"location":"api/accessibility.h/","text":"accessibility.h Specifies the variables available in the FREX shader API to describe accessibility preferences that affect visuals. See FREX Shader API.md for license and general informaiton. const float frx_fovEffects FOV Effects. Defaults to 1.0 when unavailable. const float frx_distortionEffects Distortion Effects. Defaults to 1.0 when unavailable. const int frx_hideLightningFlashes Hide Lightning Flashes. 1 when ON, 0 otherwise. This setting's effect is precomputed in frx_skyFlashStrength. No need to multiply it manually to that variable. Defaults to 0 when unavailable. const float frx_darknessPulsing Darkness Pulsing. This setting's effect is precomputed in frx_darknessEffectFactor. No need to blend it manually to that variable. Defaults to 1.0 when unavailable. const int frx_highContrast High Contrast. 1 when ON, 0 otherwise. Defaults to 0 when unavailable. const float frx_damageTilt Damage Tilt. Defaults to 1.0 when unavailable. const float frx_glintStrength Glint Strength. Defaults to 1.0 when unavailable. const float frx_glintSpeed Glint Speed. Defaults to 1.0 when unavailable.","title":"accessibility.h"},{"location":"api/accessibility.h/#accessibilityh","text":"Specifies the variables available in the FREX shader API to describe accessibility preferences that affect visuals. See FREX Shader API.md for license and general informaiton.","title":"accessibility.h"},{"location":"api/accessibility.h/#const-float-frx_foveffects","text":"FOV Effects. Defaults to 1.0 when unavailable.","title":"const float frx_fovEffects"},{"location":"api/accessibility.h/#const-float-frx_distortioneffects","text":"Distortion Effects. Defaults to 1.0 when unavailable.","title":"const float frx_distortionEffects"},{"location":"api/accessibility.h/#const-int-frx_hidelightningflashes","text":"Hide Lightning Flashes. 1 when ON, 0 otherwise. This setting's effect is precomputed in frx_skyFlashStrength. No need to multiply it manually to that variable. Defaults to 0 when unavailable.","title":"const int frx_hideLightningFlashes"},{"location":"api/accessibility.h/#const-float-frx_darknesspulsing","text":"Darkness Pulsing. This setting's effect is precomputed in frx_darknessEffectFactor. No need to blend it manually to that variable. Defaults to 1.0 when unavailable.","title":"const float frx_darknessPulsing"},{"location":"api/accessibility.h/#const-int-frx_highcontrast","text":"High Contrast. 1 when ON, 0 otherwise. Defaults to 0 when unavailable.","title":"const int frx_highContrast"},{"location":"api/accessibility.h/#const-float-frx_damagetilt","text":"Damage Tilt. Defaults to 1.0 when unavailable.","title":"const float frx_damageTilt"},{"location":"api/accessibility.h/#const-float-frx_glintstrength","text":"Glint Strength. Defaults to 1.0 when unavailable.","title":"const float frx_glintStrength"},{"location":"api/accessibility.h/#const-float-frx_glintspeed","text":"Glint Speed. Defaults to 1.0 when unavailable.","title":"const float frx_glintSpeed"},{"location":"api/fog.h/","text":"fog.h Specifies the variables available in the FREX shader API to describe fog parameters for the current primitive. See FREX Shader API.md for license and general informaiton. const int frx_fogEnabled Equals 1 if fog is enabled for the current render pass. const float frx_fogStart The starting distance for fog, following the conventions of vanilla fog rendering. Some pipelines with realistic fog modeling may not use this or may use it differently. const float frx_fogEnd The end distance for fog, following the conventions of vanilla fog rendering. Some pipelines with realistic fog modeling may not use this or may use it differently. const vec4 frx_fogColor The color of fog used in vanilla fog rendering for the current rendering pass. Some pipelines with realistic fog modeling may not use this or may use it differently.","title":"fog.h"},{"location":"api/fog.h/#fogh","text":"Specifies the variables available in the FREX shader API to describe fog parameters for the current primitive. See FREX Shader API.md for license and general informaiton.","title":"fog.h"},{"location":"api/fog.h/#const-int-frx_fogenabled","text":"Equals 1 if fog is enabled for the current render pass.","title":"const int frx_fogEnabled"},{"location":"api/fog.h/#const-float-frx_fogstart","text":"The starting distance for fog, following the conventions of vanilla fog rendering. Some pipelines with realistic fog modeling may not use this or may use it differently.","title":"const float frx_fogStart"},{"location":"api/fog.h/#const-float-frx_fogend","text":"The end distance for fog, following the conventions of vanilla fog rendering. Some pipelines with realistic fog modeling may not use this or may use it differently.","title":"const float frx_fogEnd"},{"location":"api/fog.h/#const-vec4-frx_fogcolor","text":"The color of fog used in vanilla fog rendering for the current rendering pass. Some pipelines with realistic fog modeling may not use this or may use it differently.","title":"const vec4 frx_fogColor"},{"location":"api/fragment.h/","text":"fragment.h Specifies the variables and methods in the FREX shader API sepcific to fragment shaders. See FREX Shader API.md for license and general informaiton. in vec4 frx_vertex VERTEX INPUTS Interpolated vertex position in camera space. in vec2 frx_texcoord Interpolated texture coordinate. For atlas textures, this is in mapped (non-normalized) coordinates. Material fragment shaders that need normalized UV coordinates should capture them in the vertex shader using one of the generic variables defined below. in vec4 frx_vertexColor Interpolated vertex color from vertex shader. in vec3 frx_vertexNormal Interpolated vertex normal in world/camera space. in vec4 frx_vertexTangent Interpoliated vertex tangent in camera/world space. Component w is -1.0 when the tangent handedness is inverted because of texture flipping, and 1.0 normally. in vec3 frx_vertexLight Interpolated vanilla lighting data from CPU. Depending on the context or lighting model in effect, this may not be a unit vector and/or unused. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). X: Block light intensity from vertex shader. Y: Sky light intensity from vertex shader. Z: AO shading from vertex shader. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. in float frx_distance Interpolated camera distance. Used for fog. Not available in depth pass. in vec4 frx_var0 Varying variables for generic use. See comments in vertex.glsl. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. in vec4 frx_var1 in vec4 frx_var2 in vec4 frx_var3 const vec4 frx_sampleColor FRAGMENT INPUT SAMPLES The unmodified color sampled from the base color texture. Interpretation of this color depends on frx_fragMetalness, as described in the comments for that variable. vec4 frx_fragColor FRAGMENT VARIABLES These can be modified by material shaders and are consumed by pipelline shaders for shading and framebuffer output. The base color output for this fragment. Initial value when frx_materialFragment() is called will be frx_vertexColor frx_sampleColor. Interpretation of this color depends on frx_fragMetalness, as described in the comments for that variable. float frx_fragReflectance Controls if the fragment material is dialectric or metallic. For dialectric materials, this provides the F0 value. The range of values is not continuous to maximize floating point precision in useful ranges. Dialectic materials will have values ranging from 0.0 to 0.1 and metals will have the value 1.0. When the material is dialectric, frx_fragColor models diffuse reflected color and frx_fragReflectance is the linear monochrome specular reflectance (F0). When the material is metallic, frx_fragColor models specular reflectance, which for metals is often not uniform across the light spectrum and responsible for the perceived color of metals. Initial value when frx_materialFragment() is called will be sampled from the metalness texture map. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED. vec3 frx_fragNormal Fragment normal in tangent space. Initial value when frx_materialFragment() is called will be sampled from the normal map. The pipeline shader will consume this for lighting. If any transformation is needed because of smoothed vertex normals or because the pipeline computes lighting in world space, those transformations will be done by the pipeline shader after frx_materialFragment() runs. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED. float frx_fragHeight Base height map value to be consumed by pipeline for lighting. Values range from -0.25 to 0.25 and represent distance below or above the triangle plane in tangent space. Initial value when frx_materialFragment() is called will be sampled from the height texture map. The primary use for this by material shaders is to provide PBR support for animated, proecedural surfaces. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED. float frx_fragRoughness Models random light scattering caused by tiny surface irregularities. Values range from 0.0 (perfectly smooth) to 1.0 (rough as possible.) Initial value when frx_materialFragment() is called will be sampled from the roughness texture map. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED. float frx_fragEmissive Emissive value of this fragment. Initial value when frx_materialFragment() is called will be frx_sampleEmissive if material maps are available, or frx_matEmissiveFactor otherwise. The pipeline shader will consume this for lighting after frx_materialFragment() runs. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. vec3 frx_fragLight Lighting data for this fragment. Depending on the context or lighting model in effect, these values may not be used or may be used differently. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). X: Block light intensity. Initialized to frx_vertexLight.x. Y: Sky light intensity. Initialized to frx_vertexLight.y; Z: Macro AO shading. Initialized to frx_vertexLight.z Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. float frx_fragAo Models self-shading of small variations in irregular surfaces. It should not be used for shading by other objects in the world. Initial value when frx_materialFragment() is called will be sampled from the AO texture map. The primary use for this by material shaders is to provide PBR support for animated, proecedural surfaces. Macro-scale AO is controlled and applied by the pipeline. See frx_fragDisableAo. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED. bool frx_fragEnableAo Controls macro-scale AO shading applied by the pipeline based on proxmity of other objects in the world. Initialized to !frx_matDisableAo. Depending on the context or lighting model in effect, this may not be used or may be used differently. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. bool frx_fragEnableDiffuse Controls direcional shading applied by the pipeline based on surface normals and light sources. Initialized to !frx_matDisableDiffuse. Depending on the context or lighting model in effect, this may not be used or may be used differently. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. frx_materialFragment() [PROTOTYPE] * * * * * * * * * * API METHODS Called by renderer after all variables are initialized and before frx_pipelineFragment() is called to output a fragment. The running fragment shader will have multiple, renamed versions of this method - one for each unique material fragment shader present in the game. The specific method called is controlled by the material associated with the current triangle. If the current material does not define a custom material shader, no extra processing will happen before frx_pipelineFragment() is called. frx_pipelineFragment() [PROTOTYPE] Called by renderer after frx_materialFragment() completes. Pipeline authors implement this method to read fragment data, apply transformation or shading and output to one or more framebuffer attachments. These steps are specific to the design of each pipeline. The pipeline shader is responsible for ALL WRITES. The renderer will not update depth or any color attachment.","title":"fragment.h"},{"location":"api/fragment.h/#fragmenth","text":"Specifies the variables and methods in the FREX shader API sepcific to fragment shaders. See FREX Shader API.md for license and general informaiton.","title":"fragment.h"},{"location":"api/fragment.h/#in-vec4-frx_vertex","text":"VERTEX INPUTS Interpolated vertex position in camera space.","title":"in vec4 frx_vertex"},{"location":"api/fragment.h/#in-vec2-frx_texcoord","text":"Interpolated texture coordinate. For atlas textures, this is in mapped (non-normalized) coordinates. Material fragment shaders that need normalized UV coordinates should capture them in the vertex shader using one of the generic variables defined below.","title":"in vec2 frx_texcoord"},{"location":"api/fragment.h/#in-vec4-frx_vertexcolor","text":"Interpolated vertex color from vertex shader.","title":"in vec4 frx_vertexColor"},{"location":"api/fragment.h/#in-vec3-frx_vertexnormal","text":"Interpolated vertex normal in world/camera space.","title":"in vec3 frx_vertexNormal"},{"location":"api/fragment.h/#in-vec4-frx_vertextangent","text":"Interpoliated vertex tangent in camera/world space. Component w is -1.0 when the tangent handedness is inverted because of texture flipping, and 1.0 normally.","title":"in vec4 frx_vertexTangent"},{"location":"api/fragment.h/#in-vec3-frx_vertexlight","text":"Interpolated vanilla lighting data from CPU. Depending on the context or lighting model in effect, this may not be a unit vector and/or unused. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). X: Block light intensity from vertex shader. Y: Sky light intensity from vertex shader. Z: AO shading from vertex shader. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"in vec3 frx_vertexLight"},{"location":"api/fragment.h/#in-float-frx_distance","text":"Interpolated camera distance. Used for fog. Not available in depth pass.","title":"in float frx_distance"},{"location":"api/fragment.h/#in-vec4-frx_var0","text":"Varying variables for generic use. See comments in vertex.glsl. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"in vec4 frx_var0"},{"location":"api/fragment.h/#in-vec4-frx_var1","text":"","title":"in vec4 frx_var1"},{"location":"api/fragment.h/#in-vec4-frx_var2","text":"","title":"in vec4 frx_var2"},{"location":"api/fragment.h/#in-vec4-frx_var3","text":"","title":"in vec4 frx_var3"},{"location":"api/fragment.h/#const-vec4-frx_samplecolor","text":"FRAGMENT INPUT SAMPLES The unmodified color sampled from the base color texture. Interpretation of this color depends on frx_fragMetalness, as described in the comments for that variable.","title":"const vec4 frx_sampleColor"},{"location":"api/fragment.h/#vec4-frx_fragcolor","text":"FRAGMENT VARIABLES These can be modified by material shaders and are consumed by pipelline shaders for shading and framebuffer output. The base color output for this fragment. Initial value when frx_materialFragment() is called will be frx_vertexColor frx_sampleColor. Interpretation of this color depends on frx_fragMetalness, as described in the comments for that variable.","title":"vec4 frx_fragColor"},{"location":"api/fragment.h/#float-frx_fragreflectance","text":"Controls if the fragment material is dialectric or metallic. For dialectric materials, this provides the F0 value. The range of values is not continuous to maximize floating point precision in useful ranges. Dialectic materials will have values ranging from 0.0 to 0.1 and metals will have the value 1.0. When the material is dialectric, frx_fragColor models diffuse reflected color and frx_fragReflectance is the linear monochrome specular reflectance (F0). When the material is metallic, frx_fragColor models specular reflectance, which for metals is often not uniform across the light spectrum and responsible for the perceived color of metals. Initial value when frx_materialFragment() is called will be sampled from the metalness texture map. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED.","title":"float frx_fragReflectance"},{"location":"api/fragment.h/#vec3-frx_fragnormal","text":"Fragment normal in tangent space. Initial value when frx_materialFragment() is called will be sampled from the normal map. The pipeline shader will consume this for lighting. If any transformation is needed because of smoothed vertex normals or because the pipeline computes lighting in world space, those transformations will be done by the pipeline shader after frx_materialFragment() runs. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED.","title":"vec3 frx_fragNormal"},{"location":"api/fragment.h/#float-frx_fragheight","text":"Base height map value to be consumed by pipeline for lighting. Values range from -0.25 to 0.25 and represent distance below or above the triangle plane in tangent space. Initial value when frx_materialFragment() is called will be sampled from the height texture map. The primary use for this by material shaders is to provide PBR support for animated, proecedural surfaces. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED.","title":"float frx_fragHeight"},{"location":"api/fragment.h/#float-frx_fragroughness","text":"Models random light scattering caused by tiny surface irregularities. Values range from 0.0 (perfectly smooth) to 1.0 (rough as possible.) Initial value when frx_materialFragment() is called will be sampled from the roughness texture map. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED.","title":"float frx_fragRoughness"},{"location":"api/fragment.h/#float-frx_fragemissive","text":"Emissive value of this fragment. Initial value when frx_materialFragment() is called will be frx_sampleEmissive if material maps are available, or frx_matEmissiveFactor otherwise. The pipeline shader will consume this for lighting after frx_materialFragment() runs. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"float frx_fragEmissive"},{"location":"api/fragment.h/#vec3-frx_fraglight","text":"Lighting data for this fragment. Depending on the context or lighting model in effect, these values may not be used or may be used differently. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). X: Block light intensity. Initialized to frx_vertexLight.x. Y: Sky light intensity. Initialized to frx_vertexLight.y; Z: Macro AO shading. Initialized to frx_vertexLight.z Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"vec3 frx_fragLight"},{"location":"api/fragment.h/#float-frx_fragao","text":"Models self-shading of small variations in irregular surfaces. It should not be used for shading by other objects in the world. Initial value when frx_materialFragment() is called will be sampled from the AO texture map. The primary use for this by material shaders is to provide PBR support for animated, proecedural surfaces. Macro-scale AO is controlled and applied by the pipeline. See frx_fragDisableAo. Not available in depth pass. Not available if PBR is inactive. Gate usage with #ifdef PBR_ENABLED.","title":"float frx_fragAo"},{"location":"api/fragment.h/#bool-frx_fragenableao","text":"Controls macro-scale AO shading applied by the pipeline based on proxmity of other objects in the world. Initialized to !frx_matDisableAo. Depending on the context or lighting model in effect, this may not be used or may be used differently. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"bool frx_fragEnableAo"},{"location":"api/fragment.h/#bool-frx_fragenablediffuse","text":"Controls direcional shading applied by the pipeline based on surface normals and light sources. Initialized to !frx_matDisableDiffuse. Depending on the context or lighting model in effect, this may not be used or may be used differently. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"bool frx_fragEnableDiffuse"},{"location":"api/fragment.h/#frx_materialfragment-prototype","text":"API METHODS Called by renderer after all variables are initialized and before frx_pipelineFragment() is called to output a fragment. The running fragment shader will have multiple, renamed versions of this method - one for each unique material fragment shader present in the game. The specific method called is controlled by the material associated with the current triangle. If the current material does not define a custom material shader, no extra processing will happen before frx_pipelineFragment() is called.","title":"frx_materialFragment() [PROTOTYPE]**********"},{"location":"api/fragment.h/#frx_pipelinefragment-prototype","text":"Called by renderer after frx_materialFragment() completes. Pipeline authors implement this method to read fragment data, apply transformation or shading and output to one or more framebuffer attachments. These steps are specific to the design of each pipeline. The pipeline shader is responsible for ALL WRITES. The renderer will not update depth or any color attachment.","title":"frx_pipelineFragment() [PROTOTYPE]"},{"location":"api/header.h/","text":"header.h Preprocessor: #version 330 Preprocessor: #define VANILLA_LIGHTING Preprocessor: #define ANIMATED_FOLIAGE Preprocessor: #define VERTEX_SHADER Preprocessor: #define SHADOW_MAP_PRESENT Preprocessor: #define SHADOW_MAP_SIZE 1024 Preprocessor: #define DEPTH_PASS Preprocessor: #define PBR_ENABLED","title":"header.h"},{"location":"api/header.h/#headerh","text":"","title":"header.h"},{"location":"api/header.h/#preprocessor-version-330","text":"","title":"Preprocessor: #version 330"},{"location":"api/header.h/#preprocessor-define-vanilla_lighting","text":"","title":"Preprocessor: #define VANILLA_LIGHTING"},{"location":"api/header.h/#preprocessor-define-animated_foliage","text":"","title":"Preprocessor: #define ANIMATED_FOLIAGE"},{"location":"api/header.h/#preprocessor-define-vertex_shader","text":"","title":"Preprocessor: #define VERTEX_SHADER"},{"location":"api/header.h/#preprocessor-define-shadow_map_present","text":"","title":"Preprocessor: #define SHADOW_MAP_PRESENT"},{"location":"api/header.h/#preprocessor-define-shadow_map_size-1024","text":"","title":"Preprocessor: #define SHADOW_MAP_SIZE 1024"},{"location":"api/header.h/#preprocessor-define-depth_pass","text":"","title":"Preprocessor: #define DEPTH_PASS"},{"location":"api/header.h/#preprocessor-define-pbr_enabled","text":"","title":"Preprocessor: #define PBR_ENABLED"},{"location":"api/material.h/","text":"material.h Specifies the variables and methods available in the FREX shader API to describe the material properties of the current primitive.in See FREX Shader API.md for license and general informaiton. const int frx_matEmissive Equals 1 when material is emissive, zero otherwise. For emissive materials, this is on/off, not a range. const int frx_matCutout Equals 1 when material is cutout. When 1, fragments will be discarded if alpha < 0.5. const int frx_matUnmipped Equals 1 when material has Level of Detail (mip mapping) disabled. Zero otherwise. Currently the RenderMaterail finder only allows this for cutout materials. const int frx_matDisableAo Equals 1 when material is marked to disable ambient occlusion shading. Zero otherwise. const int frx_matDisableDiffuse Equals 1 when material is marked to disable \"diffuse\" shading. Zero otherwise. This may have a different or no effect in non-vanilla lighting models. const int frx_matHurt Equals 1 when should render the red \"hurt\" overlay. Zero otherwise. Mostly for use in pipeline shaders - material shaders aren't expected to handle. const int frx_matFlash Equals 1 when should render the white \"flash\" overlay. Zero otherwise. Mostly for use in pipeline shaders - material shaders aren't expected to handle. const int frx_matGlint Equals 1 if material has enchantment glint, 0 otherwise. const int frx_matGlintEntity Equals 1 when enchanted_glint_entity texture should be used for glint rendering, 0 otherwise. const float frx_matExposure RESERVED FOR FUTURE FEATURE - not yet implemented. Coarse indication of where the surface is located. Zero means the surface is not exposed to the sky and cannot get wet or otherwise be affected from directly above. Values 1.0, 2.0 and 3.0 indicate icy, temperate or hot biome temperatures, respectively. Values > 0 also mean the surface exposed to the sky. Does not mean it is facing up - check normals for that - but does it mean it could get wet/icy/etc.","title":"material.h"},{"location":"api/material.h/#materialh","text":"Specifies the variables and methods available in the FREX shader API to describe the material properties of the current primitive.in See FREX Shader API.md for license and general informaiton.","title":"material.h"},{"location":"api/material.h/#const-int-frx_matemissive","text":"Equals 1 when material is emissive, zero otherwise. For emissive materials, this is on/off, not a range.","title":"const int frx_matEmissive"},{"location":"api/material.h/#const-int-frx_matcutout","text":"Equals 1 when material is cutout. When 1, fragments will be discarded if alpha < 0.5.","title":"const int frx_matCutout"},{"location":"api/material.h/#const-int-frx_matunmipped","text":"Equals 1 when material has Level of Detail (mip mapping) disabled. Zero otherwise. Currently the RenderMaterail finder only allows this for cutout materials.","title":"const int frx_matUnmipped"},{"location":"api/material.h/#const-int-frx_matdisableao","text":"Equals 1 when material is marked to disable ambient occlusion shading. Zero otherwise.","title":"const int frx_matDisableAo"},{"location":"api/material.h/#const-int-frx_matdisablediffuse","text":"Equals 1 when material is marked to disable \"diffuse\" shading. Zero otherwise. This may have a different or no effect in non-vanilla lighting models.","title":"const int frx_matDisableDiffuse"},{"location":"api/material.h/#const-int-frx_mathurt","text":"Equals 1 when should render the red \"hurt\" overlay. Zero otherwise. Mostly for use in pipeline shaders - material shaders aren't expected to handle.","title":"const int frx_matHurt"},{"location":"api/material.h/#const-int-frx_matflash","text":"Equals 1 when should render the white \"flash\" overlay. Zero otherwise. Mostly for use in pipeline shaders - material shaders aren't expected to handle.","title":"const int frx_matFlash"},{"location":"api/material.h/#const-int-frx_matglint","text":"Equals 1 if material has enchantment glint, 0 otherwise.","title":"const int frx_matGlint"},{"location":"api/material.h/#const-int-frx_matglintentity","text":"Equals 1 when enchanted_glint_entity texture should be used for glint rendering, 0 otherwise.","title":"const int frx_matGlintEntity"},{"location":"api/material.h/#const-float-frx_matexposure","text":"RESERVED FOR FUTURE FEATURE - not yet implemented. Coarse indication of where the surface is located. Zero means the surface is not exposed to the sky and cannot get wet or otherwise be affected from directly above. Values 1.0, 2.0 and 3.0 indicate icy, temperate or hot biome temperatures, respectively. Values > 0 also mean the surface exposed to the sky. Does not mean it is facing up - check normals for that - but does it mean it could get wet/icy/etc.","title":"const float frx_matExposure"},{"location":"api/player.h/","text":"player.h Specifies the variables and methods available in the FREX shader API to access infomration about the player. See FREX Shader API.md for license and general informaiton. const float frx_effectModifier Magnitude of effects that affect vision: night vision, being in fluid, etc. Experimental, likely to change. const float frx_darknessEffectFactor Brightness manipulation factor when player has \"Darkness\" effect. Value is interpolated between 0 for lowest brightness, and 1 for full brightness. Note that this factor is pre-applied to lightmap texture. It is meant for custom lighting models or visual effects. const vec4 frx_heldLight Color and magnitude of light source held by player in either hand. RGB are the light color, alpha channel holds the 0-1 magnitude. Magnitude 1 currently represents a source that can reach 15 blocks. This scale is subject to change. If the player is not holding a light source, all values are zero. const float frx_heldLightInnerRadius A value less than 2PI radians should create a spot light effect. This is the angle of full brightness within the light cone. Attenuation is assumed to be the same as for non-spot lights. const float frx_heldLightOuterRadius The angle of reduced brightness around the inner light cone. If greater than frx_heldLightInnerConeAngle should create a fall-off effect around a spot light. Attenuation is assumed to be the same as for non-spot lights. const int frx_effectSpeed Player effect indicators. Will equal 1 when player has the given effect. Includes all vanilla player effects as of 1.19 const int frx_effectSlowness const int frx_effectHast const int frx_effectMiningFatigue const int frx_effectStrength const int frx_effectInstantHealth const int frx_effectInstantDamage const int frx_effectJumpBoost const int frx_effectNausea const int frx_effectRegeneration const int frx_effectResistance const int frx_effectFireResistance const int frx_effectWaterBreathing const int frx_effectInvisibility const int frx_effectBlindness const int frx_effectNightVision const int frx_effectHunger const int frx_effectWeakness const int frx_effectPoison const int frx_effectWither const int frx_effectHealthBoost const int frx_effectAbsorption const int frx_effectSaturation const int frx_effectGlowing const int frx_effectLevitation const int frx_effectLuck const int frx_effectUnluck const int frx_effectSlowFalling const int frx_effectConduitPower const int frx_effectDolphinsGrace const int frx_effectBadOmen const int frx_effectHeroOfTheVillage const int frx_effectDarkness const int frx_playerEyeInFluid Player situation indicators. Will equal 1 when the situation is true. const int frx_playerEyeInWater const int frx_playerEyeInLava const int frx_playerEyeInSnow const int frx_playerSneaking const int frx_playerSwimming const int frx_playerSneakingPose const int frx_playerSwimmingPose const int frx_playerCreative const int frx_playerSpectator const int frx_playerRiding const int frx_playerOnFire const int frx_playerIsFreezing const int frx_playerSleeping const int frx_playerSprinting const int frx_playerWet const float frx_playerMood Value of timer that triggers \"spooky\" sounds when player is underground. Range 0-1. const vec3 frx_eyePos Eye position in world coordinates. const vec2 frx_eyeBrightness Normalized, linear light level at player/viewer eye position. Zero is no light and 1 is max. No correction for gamma, dimension, etc. Component x is block and y is sky. const vec2 frx_smoothedEyeBrightness Same as frx_eyeBrightness but with exponential smoothing. Optionally, can smooth only decreases, leaving increases instant. Speed & bidirectionality are controlled in pipeline config.","title":"player.h"},{"location":"api/player.h/#playerh","text":"Specifies the variables and methods available in the FREX shader API to access infomration about the player. See FREX Shader API.md for license and general informaiton.","title":"player.h"},{"location":"api/player.h/#const-float-frx_effectmodifier","text":"Magnitude of effects that affect vision: night vision, being in fluid, etc. Experimental, likely to change.","title":"const float frx_effectModifier"},{"location":"api/player.h/#const-float-frx_darknesseffectfactor","text":"Brightness manipulation factor when player has \"Darkness\" effect. Value is interpolated between 0 for lowest brightness, and 1 for full brightness. Note that this factor is pre-applied to lightmap texture. It is meant for custom lighting models or visual effects.","title":"const float frx_darknessEffectFactor"},{"location":"api/player.h/#const-vec4-frx_heldlight","text":"Color and magnitude of light source held by player in either hand. RGB are the light color, alpha channel holds the 0-1 magnitude. Magnitude 1 currently represents a source that can reach 15 blocks. This scale is subject to change. If the player is not holding a light source, all values are zero.","title":"const vec4 frx_heldLight"},{"location":"api/player.h/#const-float-frx_heldlightinnerradius","text":"A value less than 2PI radians should create a spot light effect. This is the angle of full brightness within the light cone. Attenuation is assumed to be the same as for non-spot lights.","title":"const float frx_heldLightInnerRadius"},{"location":"api/player.h/#const-float-frx_heldlightouterradius","text":"The angle of reduced brightness around the inner light cone. If greater than frx_heldLightInnerConeAngle should create a fall-off effect around a spot light. Attenuation is assumed to be the same as for non-spot lights.","title":"const float frx_heldLightOuterRadius"},{"location":"api/player.h/#const-int-frx_effectspeed","text":"Player effect indicators. Will equal 1 when player has the given effect. Includes all vanilla player effects as of 1.19","title":"const int frx_effectSpeed"},{"location":"api/player.h/#const-int-frx_effectslowness","text":"","title":"const int frx_effectSlowness"},{"location":"api/player.h/#const-int-frx_effecthast","text":"","title":"const int frx_effectHast"},{"location":"api/player.h/#const-int-frx_effectminingfatigue","text":"","title":"const int frx_effectMiningFatigue"},{"location":"api/player.h/#const-int-frx_effectstrength","text":"","title":"const int frx_effectStrength"},{"location":"api/player.h/#const-int-frx_effectinstanthealth","text":"","title":"const int frx_effectInstantHealth"},{"location":"api/player.h/#const-int-frx_effectinstantdamage","text":"","title":"const int frx_effectInstantDamage"},{"location":"api/player.h/#const-int-frx_effectjumpboost","text":"","title":"const int frx_effectJumpBoost"},{"location":"api/player.h/#const-int-frx_effectnausea","text":"","title":"const int frx_effectNausea"},{"location":"api/player.h/#const-int-frx_effectregeneration","text":"","title":"const int frx_effectRegeneration"},{"location":"api/player.h/#const-int-frx_effectresistance","text":"","title":"const int frx_effectResistance"},{"location":"api/player.h/#const-int-frx_effectfireresistance","text":"","title":"const int frx_effectFireResistance"},{"location":"api/player.h/#const-int-frx_effectwaterbreathing","text":"","title":"const int frx_effectWaterBreathing"},{"location":"api/player.h/#const-int-frx_effectinvisibility","text":"","title":"const int frx_effectInvisibility"},{"location":"api/player.h/#const-int-frx_effectblindness","text":"","title":"const int frx_effectBlindness"},{"location":"api/player.h/#const-int-frx_effectnightvision","text":"","title":"const int frx_effectNightVision"},{"location":"api/player.h/#const-int-frx_effecthunger","text":"","title":"const int frx_effectHunger"},{"location":"api/player.h/#const-int-frx_effectweakness","text":"","title":"const int frx_effectWeakness"},{"location":"api/player.h/#const-int-frx_effectpoison","text":"","title":"const int frx_effectPoison"},{"location":"api/player.h/#const-int-frx_effectwither","text":"","title":"const int frx_effectWither"},{"location":"api/player.h/#const-int-frx_effecthealthboost","text":"","title":"const int frx_effectHealthBoost"},{"location":"api/player.h/#const-int-frx_effectabsorption","text":"","title":"const int frx_effectAbsorption"},{"location":"api/player.h/#const-int-frx_effectsaturation","text":"","title":"const int frx_effectSaturation"},{"location":"api/player.h/#const-int-frx_effectglowing","text":"","title":"const int frx_effectGlowing"},{"location":"api/player.h/#const-int-frx_effectlevitation","text":"","title":"const int frx_effectLevitation"},{"location":"api/player.h/#const-int-frx_effectluck","text":"","title":"const int frx_effectLuck"},{"location":"api/player.h/#const-int-frx_effectunluck","text":"","title":"const int frx_effectUnluck"},{"location":"api/player.h/#const-int-frx_effectslowfalling","text":"","title":"const int frx_effectSlowFalling"},{"location":"api/player.h/#const-int-frx_effectconduitpower","text":"","title":"const int frx_effectConduitPower"},{"location":"api/player.h/#const-int-frx_effectdolphinsgrace","text":"","title":"const int frx_effectDolphinsGrace"},{"location":"api/player.h/#const-int-frx_effectbadomen","text":"","title":"const int frx_effectBadOmen"},{"location":"api/player.h/#const-int-frx_effectheroofthevillage","text":"","title":"const int frx_effectHeroOfTheVillage"},{"location":"api/player.h/#const-int-frx_effectdarkness","text":"","title":"const int frx_effectDarkness"},{"location":"api/player.h/#const-int-frx_playereyeinfluid","text":"Player situation indicators. Will equal 1 when the situation is true.","title":"const int frx_playerEyeInFluid"},{"location":"api/player.h/#const-int-frx_playereyeinwater","text":"","title":"const int frx_playerEyeInWater"},{"location":"api/player.h/#const-int-frx_playereyeinlava","text":"","title":"const int frx_playerEyeInLava"},{"location":"api/player.h/#const-int-frx_playereyeinsnow","text":"","title":"const int frx_playerEyeInSnow"},{"location":"api/player.h/#const-int-frx_playersneaking","text":"","title":"const int frx_playerSneaking"},{"location":"api/player.h/#const-int-frx_playerswimming","text":"","title":"const int frx_playerSwimming"},{"location":"api/player.h/#const-int-frx_playersneakingpose","text":"","title":"const int frx_playerSneakingPose"},{"location":"api/player.h/#const-int-frx_playerswimmingpose","text":"","title":"const int frx_playerSwimmingPose"},{"location":"api/player.h/#const-int-frx_playercreative","text":"","title":"const int frx_playerCreative"},{"location":"api/player.h/#const-int-frx_playerspectator","text":"","title":"const int frx_playerSpectator"},{"location":"api/player.h/#const-int-frx_playerriding","text":"","title":"const int frx_playerRiding"},{"location":"api/player.h/#const-int-frx_playeronfire","text":"","title":"const int frx_playerOnFire"},{"location":"api/player.h/#const-int-frx_playerisfreezing","text":"","title":"const int frx_playerIsFreezing"},{"location":"api/player.h/#const-int-frx_playersleeping","text":"","title":"const int frx_playerSleeping"},{"location":"api/player.h/#const-int-frx_playersprinting","text":"","title":"const int frx_playerSprinting"},{"location":"api/player.h/#const-int-frx_playerwet","text":"","title":"const int frx_playerWet"},{"location":"api/player.h/#const-float-frx_playermood","text":"Value of timer that triggers \"spooky\" sounds when player is underground. Range 0-1.","title":"const float frx_playerMood"},{"location":"api/player.h/#const-vec3-frx_eyepos","text":"Eye position in world coordinates.","title":"const vec3 frx_eyePos"},{"location":"api/player.h/#const-vec2-frx_eyebrightness","text":"Normalized, linear light level at player/viewer eye position. Zero is no light and 1 is max. No correction for gamma, dimension, etc. Component x is block and y is sky.","title":"const vec2 frx_eyeBrightness"},{"location":"api/player.h/#const-vec2-frx_smoothedeyebrightness","text":"Same as frx_eyeBrightness but with exponential smoothing. Optionally, can smooth only decreases, leaving increases instant. Speed & bidirectionality are controlled in pipeline config.","title":"const vec2 frx_smoothedEyeBrightness"},{"location":"api/sampler.h/","text":"sampler.h Specifies the variables and methods available in the FREX shader API to access samplers directly. See FREX Shader API.md for license and general informaiton. uniform sampler2D frxs_baseColor frx_mapNormalizedUV(vec2 coord) [PROTOTYPE] When a texture atlas is in use, the renderer will automatically map from normalized coordinates to texture coordinates before the fragment shader runs. But this doesn't help if you want to re-sample during fragment shading using normalized coordinates. This function will remap normalized coordinates to atlas coordinates. It has no effect when the bound texture is not an atlas texture. frx_normalizeMappedUV(vec2 coord) [PROTOTYPE] Takes texture atlas coordinates and remaps them to normalized. Has no effect when the bound texture is not an atlas texture. uniform sampler2D frxs_lightmap uniform sampler2DArrayShadow frxs_shadowMap Shadow-type sampler for shadow map texture, useful for final map testing and exploits hardware accumulation of shadow test results Same underlying image as frxs_shadowMapTexture. Available only in fragment shader when SHADOW_MAP_PRESENT is defined. uniform sampler2DArray frxs_shadowMapTexture Regular sampler for shadow map texture, useful for probing depth at specific points for PCSS or Contact-Hardening Shadows. Same underlying image as frxs_shadowMapTexture. Available only in fragment shader when SHADOW_MAP_PRESENT is defined.","title":"sampler.h"},{"location":"api/sampler.h/#samplerh","text":"Specifies the variables and methods available in the FREX shader API to access samplers directly. See FREX Shader API.md for license and general informaiton.","title":"sampler.h"},{"location":"api/sampler.h/#uniform-sampler2d-frxs_basecolor","text":"","title":"uniform sampler2D frxs_baseColor"},{"location":"api/sampler.h/#frx_mapnormalizeduvvec2-coord-prototype","text":"When a texture atlas is in use, the renderer will automatically map from normalized coordinates to texture coordinates before the fragment shader runs. But this doesn't help if you want to re-sample during fragment shading using normalized coordinates. This function will remap normalized coordinates to atlas coordinates. It has no effect when the bound texture is not an atlas texture.","title":"frx_mapNormalizedUV(vec2 coord) [PROTOTYPE]"},{"location":"api/sampler.h/#frx_normalizemappeduvvec2-coord-prototype","text":"Takes texture atlas coordinates and remaps them to normalized. Has no effect when the bound texture is not an atlas texture.","title":"frx_normalizeMappedUV(vec2 coord) [PROTOTYPE]"},{"location":"api/sampler.h/#uniform-sampler2d-frxs_lightmap","text":"","title":"uniform sampler2D frxs_lightmap"},{"location":"api/sampler.h/#uniform-sampler2darrayshadow-frxs_shadowmap","text":"Shadow-type sampler for shadow map texture, useful for final map testing and exploits hardware accumulation of shadow test results Same underlying image as frxs_shadowMapTexture. Available only in fragment shader when SHADOW_MAP_PRESENT is defined.","title":"uniform sampler2DArrayShadow frxs_shadowMap"},{"location":"api/sampler.h/#uniform-sampler2darray-frxs_shadowmaptexture","text":"Regular sampler for shadow map texture, useful for probing depth at specific points for PCSS or Contact-Hardening Shadows. Same underlying image as frxs_shadowMapTexture. Available only in fragment shader when SHADOW_MAP_PRESENT is defined.","title":"uniform sampler2DArray frxs_shadowMapTexture"},{"location":"api/vertex.h/","text":"vertex.h Specifies the variables and methods in the FREX shader API sepcific to vertex shaders. See FREX Shader API.md for license and general informaiton. out vec4 frx_vertex Vertex position in camera space. Transformation in frx_materialVertex() is the primary means for achieving animation effects. Remember that normals must be transformed separately! out vec2 frx_texcoord The texture coordinates for the vertex. Used for base color and PBR texture maps. For atlas textures, the renderer will initialize this with normalized 0-1 coordinates before calling frx_materialVertex() and convert them to mapped (non-normalized) atlas coordinates before calling frx_pipelineVertex(); out vec4 frx_vertexColor RGB vertex color, with alpha. Usage of alpha is controlled by the material blend mode: if cutout is enabled, fragment will be discarded (see: api/material.glsl) if SHADER_PASS != SHADER_PASS_SOLID fragment will be blended using the alpha channel in other cases (solid pass rendering) alpha is ignored and could be used for other purposes Vertex color is not transformed by the renderer. The renderer must not modify vertex alpha values given from the model in the solid render pass, even if the data is not used. This means mod authors can use that value for other purposes in a material shader. out vec3 frx_vertexNormal Vertex normal in camera/world space. Transformation in frx_materialVertex() is the primary means for achieving animation effects. Transforming normal in addition to vertex is important for correct lighting. out vec4 frx_vertexTangent Vertex tangent in camera/world space. Component w is -1.0 when the tangent space handedness is inverted because of texture flipping, and 1.0 normally. out vec3 frx_vertexLight Initialized with vanilla lighting data from CPU. Depending on the context or lighting model in effect, this may not be a unit vector and/or unused. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). Components are as follows: X: Block light intensity. Y: Sky light intensity. Z: AO shading. Will be initialized to 1.0 if frx_matDisableAo is true or AO is disabled in the game. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS. out vec4 frx_var0 Varying variables for generic use in material shaders. Material shader authors are encouraged to exhaust these before creating new custom out variables. This is necessary because custom shaders may be consolidated into a single shader with logic controlled via uniforms or vertex data. This is done either to reduce draw calls or as a way to achieve sorted translucency with mixed custom shaders. If we do not reuse these variables, then three bad things can happen: 1) Naming conflicts (could be avoided with care) 2) Exceed hardware/driver limits 3) Wasteful interpolation if unused varyings aren't stripped by the compiler. Authors do not need to worry about conflicting usage of these variables by other shaders in the same compilation - only a single pair of custom vertex/fragment shaders will be active for a single polygon. Note that pipeline shader devs should NOT use these. There will only ever be a single pipeline active at any time - piplines can define as many out variables as needed, within reason. Not available in depth pass. out vec4 frx_var1 out vec4 frx_var2 out vec4 frx_var3 out float frx_distance Interpolated camera distance. Used for fog. Set by pipeline shader after material shader runs. Do not modify. Not available in depth pass. frx_materialVertex() [PROTOTYPE] * * * * * * * * * * API METHODS Called by renderer after all variables are initialized and before frx_pipelineVertex() is called to update vertex outputs. The running vertex shader will have multiple, renamed versions of this method - one for each unique material vertex shader present in the game. The specific method called is controlled by the material associated with the current triangle. If the current material does not define a custom material shader, no extra processing will happen before frx_pipelineVertex() is called. frx_pipelineVertex() [PROTOTYPE] Called by renderer after frx_materialVertex() completes. Pipeline authors implement this method to read vertex data, apply transformation and update as needed. Pipeline vertex shaders may also capture additional vertex outputs as needed. These steps are specific to the design of each pipeline. The pipeline shader is responsible for ALL updates to vertex outputs, including those defined by the FREX API.","title":"vertex.h"},{"location":"api/vertex.h/#vertexh","text":"Specifies the variables and methods in the FREX shader API sepcific to vertex shaders. See FREX Shader API.md for license and general informaiton.","title":"vertex.h"},{"location":"api/vertex.h/#out-vec4-frx_vertex","text":"Vertex position in camera space. Transformation in frx_materialVertex() is the primary means for achieving animation effects. Remember that normals must be transformed separately!","title":"out vec4 frx_vertex"},{"location":"api/vertex.h/#out-vec2-frx_texcoord","text":"The texture coordinates for the vertex. Used for base color and PBR texture maps. For atlas textures, the renderer will initialize this with normalized 0-1 coordinates before calling frx_materialVertex() and convert them to mapped (non-normalized) atlas coordinates before calling frx_pipelineVertex();","title":"out vec2 frx_texcoord"},{"location":"api/vertex.h/#out-vec4-frx_vertexcolor","text":"RGB vertex color, with alpha. Usage of alpha is controlled by the material blend mode: if cutout is enabled, fragment will be discarded (see: api/material.glsl) if SHADER_PASS != SHADER_PASS_SOLID fragment will be blended using the alpha channel in other cases (solid pass rendering) alpha is ignored and could be used for other purposes Vertex color is not transformed by the renderer. The renderer must not modify vertex alpha values given from the model in the solid render pass, even if the data is not used. This means mod authors can use that value for other purposes in a material shader.","title":"out vec4 frx_vertexColor"},{"location":"api/vertex.h/#out-vec3-frx_vertexnormal","text":"Vertex normal in camera/world space. Transformation in frx_materialVertex() is the primary means for achieving animation effects. Transforming normal in addition to vertex is important for correct lighting.","title":"out vec3 frx_vertexNormal"},{"location":"api/vertex.h/#out-vec4-frx_vertextangent","text":"Vertex tangent in camera/world space. Component w is -1.0 when the tangent space handedness is inverted because of texture flipping, and 1.0 normally.","title":"out vec4 frx_vertexTangent"},{"location":"api/vertex.h/#out-vec3-frx_vertexlight","text":"Initialized with vanilla lighting data from CPU. Depending on the context or lighting model in effect, this may not be a unit vector and/or unused. The emissive flag or an emissive texture map (when supported) are generally better alternatives for achieving emissive lighting effects. All values are normalized (0-1). Components are as follows: X: Block light intensity. Y: Sky light intensity. Z: AO shading. Will be initialized to 1.0 if frx_matDisableAo is true or AO is disabled in the game. Not available in depth pass. Gate usage with #ifndef DEPTH_PASS.","title":"out vec3 frx_vertexLight"},{"location":"api/vertex.h/#out-vec4-frx_var0","text":"Varying variables for generic use in material shaders. Material shader authors are encouraged to exhaust these before creating new custom out variables. This is necessary because custom shaders may be consolidated into a single shader with logic controlled via uniforms or vertex data. This is done either to reduce draw calls or as a way to achieve sorted translucency with mixed custom shaders. If we do not reuse these variables, then three bad things can happen: 1) Naming conflicts (could be avoided with care) 2) Exceed hardware/driver limits 3) Wasteful interpolation if unused varyings aren't stripped by the compiler. Authors do not need to worry about conflicting usage of these variables by other shaders in the same compilation - only a single pair of custom vertex/fragment shaders will be active for a single polygon. Note that pipeline shader devs should NOT use these. There will only ever be a single pipeline active at any time - piplines can define as many out variables as needed, within reason. Not available in depth pass.","title":"out vec4 frx_var0"},{"location":"api/vertex.h/#out-vec4-frx_var1","text":"","title":"out vec4 frx_var1"},{"location":"api/vertex.h/#out-vec4-frx_var2","text":"","title":"out vec4 frx_var2"},{"location":"api/vertex.h/#out-vec4-frx_var3","text":"","title":"out vec4 frx_var3"},{"location":"api/vertex.h/#out-float-frx_distance","text":"Interpolated camera distance. Used for fog. Set by pipeline shader after material shader runs. Do not modify. Not available in depth pass.","title":"out float frx_distance"},{"location":"api/vertex.h/#frx_materialvertex-prototype","text":"API METHODS Called by renderer after all variables are initialized and before frx_pipelineVertex() is called to update vertex outputs. The running vertex shader will have multiple, renamed versions of this method - one for each unique material vertex shader present in the game. The specific method called is controlled by the material associated with the current triangle. If the current material does not define a custom material shader, no extra processing will happen before frx_pipelineVertex() is called.","title":"frx_materialVertex() [PROTOTYPE]**********"},{"location":"api/vertex.h/#frx_pipelinevertex-prototype","text":"Called by renderer after frx_materialVertex() completes. Pipeline authors implement this method to read vertex data, apply transformation and update as needed. Pipeline vertex shaders may also capture additional vertex outputs as needed. These steps are specific to the design of each pipeline. The pipeline shader is responsible for ALL updates to vertex outputs, including those defined by the FREX API.","title":"frx_pipelineVertex() [PROTOTYPE]"},{"location":"api/view.h/","text":"view.h Specifies the variables and methods available in the FREX shader API for coordinate spaces, transformations and camera information. See FREX Shader API.md for license and general informaiton. const vec3 frx_cameraView The view vector of the current camera in world space, normalised. const vec3 frx_entityView The view vector of the current entity focused by the camera, in world space, normalised. const vec3 frx_cameraPos Current position of the camera in world space. const vec3 frx_lastCameraPos Prior-frame position of the camera in world space. const vec4 frx_modelToWorld Translation from inbound model coordinates to world space. Conventionally this is handled with a matrix, but because inbound coordinates outside of overlay and GUI rendering are always world-aligned, this can avoid a matrix multiplication. When frx_modelOriginType() == MODEL_ORIGIN_CAMERA, inbound coordinates are relative to the camera position and this will equal frx_cameraPos(). In overlay rendering, when frx_modelOriginType() == MODEL_ORIGIN_SCREEN, this will always be zero. The fourth component is always zero and included for ease of use. const vec4 frx_modelToCamera Translation from in-bound model coordinates to view space. Conventionally this is handled with a matrix, but because inbound coordinates outside of overlay and GUI rendering are always world-algined, this can avoid a matrix multiplication. When frx_modelOriginCemera == 1, inbound coordinates are already relative to the camera position and this will always be zero. In overlay rendering, when frx_modelOriginType() == MODEL_ORIGIN_SCREEN, this will always be zero. The fourth component is always zero and included for ease of use. const bool frx_modelOriginCamera When true, vertex coordinates are relative to the camera position. Coordinates and normals are unrotated and frx_modelToWorld holds the camera position. Mutually exclusive with frx_modelOriginScreen and frx_modelOriginRegion. const bool frx_modelOriginRegion When true, vertex coordinates are relative are relative to the origin of a \"cluster\" of world render regions. Coordinates and normals are unrotated and frx_modelToWorld holds the cluster origin. Mutually exclusive with frx_modelOriginScreen and frx_modelOriginCamera. const bool frx_modelOriginScreen When true, vertex coordinates are relative to the screen and no transformations should be applied. Intended for Hand//GUI rendering. Mutually exclusive with frx_modelOriginCamera and frx_modelOriginRegion. const bool frx_isHand True when rendering hand. const bool frx_isGui True when rendering GUI. const mat4 frx_guiViewProjectionMatrix const mat3 frx_normalModelMatrix Converts camera/world space normals to view space. Incoming vertex normals are always in camera/world space. const mat4 frx_viewMatrix const mat4 frx_inverseViewMatrix const mat4 frx_lastViewMatrix const mat4 frx_projectionMatrix const mat4 frx_lastProjectionMatrix const mat4 frx_inverseProjectionMatrix const mat4 frx_viewProjectionMatrix const mat4 frx_inverseViewProjectionMatrix const mat4 frx_lastViewProjectionMatrix const mat4 frx_cleanProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_lastCleanProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_inverseCleanProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_cleanViewProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_inverseCleanViewProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_lastCleanViewProjectionMatrix No view bobbing or other effects that alter projection const mat4 frx_shadowViewMatrix const mat4 frx_inverseShadowViewMatrix frx_shadowProjectionMatrix(int index) [PROTOTYPE] Orthogonal projection matrix on light space for given cascade index 0-3. frx_shadowViewProjectionMatrix(int index) [PROTOTYPE] Combined lightspace view and orthogonal projection for given cascade index 0-3. frx_shadowCenter(int index) [PROTOTYPE] Center and radius of other projection in light space for given cascade index 0-3. const float frx_viewWidth Framebuffer width, in pixels. const float frx_viewHeight Framebuffer height, in pixels. const float frx_viewAspectRatio Framebuffer width / height. const float frx_viewBrightness User-configured brightness from game options. Values 0.0 to 1.0, with 1.0 being max brightness. const bool frx_renderTargetSolid When == 1, shader is targetting the solid-pass framebuffer. Mutually exclusive with all other frx_renderTarget_ variables. const bool frx_renderTargetTranslucent When == 1, shader is targetting the translucent-pass framebuffer for terrain. Mutually exclusive with all other frx_renderTarget_ variables. const bool frx_renderTargetParticles When == 1, shader is targetting the translucent-pass framebuffer for particles. Mutually exclusive with all other frx_renderTarget_ variables. const bool frx_renderTargetEntity When == 1, shader is targetting the translucent-pass framebuffer for entities. Mutually exclusive with all other frx_renderTarget_ variables. const float frx_viewDistance Currently configured terrain view distance, in blocks. const int frx_cameraInFluid Returns 1 when camera is in fluid. Zero otherwise. const int frx_cameraInWater Returns 1 when camera is in water. Zero otherwise. const int frx_cameraInLava Returns 1 when camera is in lava. Zero otherwise. const int frx_cameraInSnow Returns 1 when camera is in powdered snow. Zero otherwise.","title":"view.h"},{"location":"api/view.h/#viewh","text":"Specifies the variables and methods available in the FREX shader API for coordinate spaces, transformations and camera information. See FREX Shader API.md for license and general informaiton.","title":"view.h"},{"location":"api/view.h/#const-vec3-frx_cameraview","text":"The view vector of the current camera in world space, normalised.","title":"const vec3 frx_cameraView"},{"location":"api/view.h/#const-vec3-frx_entityview","text":"The view vector of the current entity focused by the camera, in world space, normalised.","title":"const vec3 frx_entityView"},{"location":"api/view.h/#const-vec3-frx_camerapos","text":"Current position of the camera in world space.","title":"const vec3 frx_cameraPos"},{"location":"api/view.h/#const-vec3-frx_lastcamerapos","text":"Prior-frame position of the camera in world space.","title":"const vec3 frx_lastCameraPos"},{"location":"api/view.h/#const-vec4-frx_modeltoworld","text":"Translation from inbound model coordinates to world space. Conventionally this is handled with a matrix, but because inbound coordinates outside of overlay and GUI rendering are always world-aligned, this can avoid a matrix multiplication. When frx_modelOriginType() == MODEL_ORIGIN_CAMERA, inbound coordinates are relative to the camera position and this will equal frx_cameraPos(). In overlay rendering, when frx_modelOriginType() == MODEL_ORIGIN_SCREEN, this will always be zero. The fourth component is always zero and included for ease of use.","title":"const vec4 frx_modelToWorld"},{"location":"api/view.h/#const-vec4-frx_modeltocamera","text":"Translation from in-bound model coordinates to view space. Conventionally this is handled with a matrix, but because inbound coordinates outside of overlay and GUI rendering are always world-algined, this can avoid a matrix multiplication. When frx_modelOriginCemera == 1, inbound coordinates are already relative to the camera position and this will always be zero. In overlay rendering, when frx_modelOriginType() == MODEL_ORIGIN_SCREEN, this will always be zero. The fourth component is always zero and included for ease of use.","title":"const vec4 frx_modelToCamera"},{"location":"api/view.h/#const-bool-frx_modelorigincamera","text":"When true, vertex coordinates are relative to the camera position. Coordinates and normals are unrotated and frx_modelToWorld holds the camera position. Mutually exclusive with frx_modelOriginScreen and frx_modelOriginRegion.","title":"const bool frx_modelOriginCamera"},{"location":"api/view.h/#const-bool-frx_modeloriginregion","text":"When true, vertex coordinates are relative are relative to the origin of a \"cluster\" of world render regions. Coordinates and normals are unrotated and frx_modelToWorld holds the cluster origin. Mutually exclusive with frx_modelOriginScreen and frx_modelOriginCamera.","title":"const bool frx_modelOriginRegion"},{"location":"api/view.h/#const-bool-frx_modeloriginscreen","text":"When true, vertex coordinates are relative to the screen and no transformations should be applied. Intended for Hand//GUI rendering. Mutually exclusive with frx_modelOriginCamera and frx_modelOriginRegion.","title":"const bool frx_modelOriginScreen"},{"location":"api/view.h/#const-bool-frx_ishand","text":"True when rendering hand.","title":"const bool frx_isHand"},{"location":"api/view.h/#const-bool-frx_isgui","text":"True when rendering GUI.","title":"const bool frx_isGui"},{"location":"api/view.h/#const-mat4-frx_guiviewprojectionmatrix","text":"","title":"const mat4 frx_guiViewProjectionMatrix"},{"location":"api/view.h/#const-mat3-frx_normalmodelmatrix","text":"Converts camera/world space normals to view space. Incoming vertex normals are always in camera/world space.","title":"const mat3 frx_normalModelMatrix"},{"location":"api/view.h/#const-mat4-frx_viewmatrix","text":"","title":"const mat4 frx_viewMatrix"},{"location":"api/view.h/#const-mat4-frx_inverseviewmatrix","text":"","title":"const mat4 frx_inverseViewMatrix"},{"location":"api/view.h/#const-mat4-frx_lastviewmatrix","text":"","title":"const mat4 frx_lastViewMatrix"},{"location":"api/view.h/#const-mat4-frx_projectionmatrix","text":"","title":"const mat4 frx_projectionMatrix"},{"location":"api/view.h/#const-mat4-frx_lastprojectionmatrix","text":"","title":"const mat4 frx_lastProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_inverseprojectionmatrix","text":"","title":"const mat4 frx_inverseProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_viewprojectionmatrix","text":"","title":"const mat4 frx_viewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_inverseviewprojectionmatrix","text":"","title":"const mat4 frx_inverseViewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_lastviewprojectionmatrix","text":"","title":"const mat4 frx_lastViewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_cleanprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_cleanProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_lastcleanprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_lastCleanProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_inversecleanprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_inverseCleanProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_cleanviewprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_cleanViewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_inversecleanviewprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_inverseCleanViewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_lastcleanviewprojectionmatrix","text":"No view bobbing or other effects that alter projection","title":"const mat4 frx_lastCleanViewProjectionMatrix"},{"location":"api/view.h/#const-mat4-frx_shadowviewmatrix","text":"","title":"const mat4 frx_shadowViewMatrix"},{"location":"api/view.h/#const-mat4-frx_inverseshadowviewmatrix","text":"","title":"const mat4 frx_inverseShadowViewMatrix"},{"location":"api/view.h/#frx_shadowprojectionmatrixint-index-prototype","text":"Orthogonal projection matrix on light space for given cascade index 0-3.","title":"frx_shadowProjectionMatrix(int index) [PROTOTYPE]"},{"location":"api/view.h/#frx_shadowviewprojectionmatrixint-index-prototype","text":"Combined lightspace view and orthogonal projection for given cascade index 0-3.","title":"frx_shadowViewProjectionMatrix(int index) [PROTOTYPE]"},{"location":"api/view.h/#frx_shadowcenterint-index-prototype","text":"Center and radius of other projection in light space for given cascade index 0-3.","title":"frx_shadowCenter(int index) [PROTOTYPE]"},{"location":"api/view.h/#const-float-frx_viewwidth","text":"Framebuffer width, in pixels.","title":"const float frx_viewWidth"},{"location":"api/view.h/#const-float-frx_viewheight","text":"Framebuffer height, in pixels.","title":"const float frx_viewHeight"},{"location":"api/view.h/#const-float-frx_viewaspectratio","text":"Framebuffer width / height.","title":"const float frx_viewAspectRatio"},{"location":"api/view.h/#const-float-frx_viewbrightness","text":"User-configured brightness from game options. Values 0.0 to 1.0, with 1.0 being max brightness.","title":"const float frx_viewBrightness"},{"location":"api/view.h/#const-bool-frx_rendertargetsolid","text":"When == 1, shader is targetting the solid-pass framebuffer. Mutually exclusive with all other frx_renderTarget_ variables.","title":"const bool frx_renderTargetSolid"},{"location":"api/view.h/#const-bool-frx_rendertargettranslucent","text":"When == 1, shader is targetting the translucent-pass framebuffer for terrain. Mutually exclusive with all other frx_renderTarget_ variables.","title":"const bool frx_renderTargetTranslucent"},{"location":"api/view.h/#const-bool-frx_rendertargetparticles","text":"When == 1, shader is targetting the translucent-pass framebuffer for particles. Mutually exclusive with all other frx_renderTarget_ variables.","title":"const bool frx_renderTargetParticles"},{"location":"api/view.h/#const-bool-frx_rendertargetentity","text":"When == 1, shader is targetting the translucent-pass framebuffer for entities. Mutually exclusive with all other frx_renderTarget_ variables.","title":"const bool frx_renderTargetEntity"},{"location":"api/view.h/#const-float-frx_viewdistance","text":"Currently configured terrain view distance, in blocks.","title":"const float frx_viewDistance"},{"location":"api/view.h/#const-int-frx_camerainfluid","text":"Returns 1 when camera is in fluid. Zero otherwise.","title":"const int frx_cameraInFluid"},{"location":"api/view.h/#const-int-frx_camerainwater","text":"Returns 1 when camera is in water. Zero otherwise.","title":"const int frx_cameraInWater"},{"location":"api/view.h/#const-int-frx_camerainlava","text":"Returns 1 when camera is in lava. Zero otherwise.","title":"const int frx_cameraInLava"},{"location":"api/view.h/#const-int-frx_camerainsnow","text":"Returns 1 when camera is in powdered snow. Zero otherwise.","title":"const int frx_cameraInSnow"},{"location":"api/world.h/","text":"world.h Specifies the variables and methods available in the FREX shader API for access to world information. See FREX Shader API.md for license and general informaiton. const float frx_renderSeconds The number of seconds this world has been rendering since the last render reload, including fractional seconds. Use this for effects that need a smoothly increasing counter. const uint frx_renderFrames The number of frames this world has been rendering since the last render reload. Use this for effects that need a discrete increasing counter. const float frx_worldDay Day of the currently rendering world - integer portion only. This is the apparent day, not the elapsed play time, which can be different due to sleeping, /set time, etc. Use this for effects that depend somehow on the season or age of the world. Received from server - may not be smoothly incremented. const float frx_worldTime Time of the currently rendering world with values 0 to 1. Zero represents the morning / start of the day cycle in Minecraft. Use this for effects that depend on the time of day. Received from server - may not be smoothly incremented. const float frx_moonSize Size of the moon the currently rendering world. Values are 0 to 1. const float frx_skyAngleRadians Rotation of the sky dome as part of the day/night cycle. Will not advance if doDaylightCycle game rule is turned off. In vanilla dimensions, zero represents the condition at tick = 0 (just after sunrise) and rotation is around the Z axis. Will be zero at noon, (world time = 6000) but vanilla adjusts the progression so that the sun is slightly over the horizon at world time = 0 and also takes its time setting as well. const vec3 frx_skyLightVector Normalized vector of the primary sky light (the sun or moon) used for shadow mapping and useful for direct sky lighting. Points towards the skylight. Will not advance if doDaylightCycle game rule is turned off. See notes on frx_skyAngleRadians() regarding asymmetry. const vec3 frx_skyLightColor Linear RGB color of the most prevalent sky light - the one that is used for shadow map and intended for directional lighting. Does not vary by time of day or for atmospheric effects but can vary based on season or other celestial variables for modded dimensions or if configured for vanilla dimensions. Not adjusted for night vision or any player effect. Does not account for underwater or any other occlusion. Not adjusted for rain, thunder, cloud cover, or lightning. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be unit vector if the world has no skylight. const float frx_skyLightIlluminance Measures intensity of direct sky light in lumens/square meter. (lux) Does not vary by time of day or for atmospheric effects but can vary based on season or other celestial variables for modded dimensions or if configured for vanilla dimensions. Also varies by moon phase for moonlight if that feature is enabled. Not adjusted for night vision or any player effect. Does not account for underwater or any other occlusion. Not adjusted for rain, thunder, cloud cover, or lightning. FREX pegs vanilla sunlight illuminace at 32,000 lux. Value could be different for modded dimensions or if configured via resource pack. Moonlight in Vanilla appears to be more intense than in the real world. If configured to mimic vanilla, moonlight will be ~100lux but can be very small or zero (or perhaps higher) in other configurations. Values assume an idealized, non-specific reference white light. When multiplied by frx_skyLightColor() the effective luminance will be somewhat less, but shaders are not expected to compensate for this. Most celestial light sources are some flavor of white, and stongly-colored lights can be handled by adjusting the illuminance in the mod/pack configuration if needed. Effective illuminance will also be reduced if light is multiplied by frx_skyLightAtmosphericColor() but that should not require any compensation because it mimics the scattering of light. Pipelines that strive for physical realism will not use that factor anyway. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be zero if the world has no skylight. const vec3 frx_skyLightAtmosphericColor Linear RGB color modifier for the most prevalent sky light - the one that is used for shadow map and intended for directional lighting. Also adjusted by time of day to account for atmospheric effects. Pipelines that model atmospheric scattering will not want this. Not adjusted for weather, lightning, night vision or any player effect. Does not account for underwater or any other occlusion. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be unit vector if the world has no skylight. const float frx_skyLightTransitionFactor Smoothing factor to help with the transition from sun to/from moon light. Ramps down to zero down as the moon set and then back up to one as the sun rises. In future, will be configurable by dimension. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be 1.0 (and mean nothing) if the world has no skylight. const float frx_skyFlashStrength Strength of sky flashing during a lightning strike. Forms a reverse sawtooth pattern with random peaks over time. UNCLAMPED, but meant to be clamped to values between 0 and 1. HDR implementation might want to use values above 1 to represent stronger flashes. Locked to 0 if Accessibility Setting > Hide Lightning Flashes is ON. const float frx_ambientIntensity Ambient light intensity of the currently rendering world. Zero represents the morning / start of the day cycle in Minecraft. Experimental, likely to change. const vec4 frx_emissiveColor Gamma-corrected max light color from lightmap texture. Updated whenever lightmap texture is updated. Multiply emissive outputs by this to be consistent with the game's brightness settings. Note that Canvas normally handles this automatically. It is exposed for exotic use cases. const float frx_rainGradient MC rain strength. Values 0 to 1. const float frx_thunderGradient MC thunder strength. Values 0 to 1. const float frx_smoothedRainGradient Same as frx_rainGradient but with exponential smoothing. Speed is controlled in pipeline config. const float frx_smoothedThunderGradient Same as frx_thunderGradient but with exponential smoothing. Speed is controlled in pipeline config. const vec3 frx_vanillaClearColor The background clear color as computed by vanilla logic. Incorporates many different factors. For use by pipelines that may want to modify and do their own clearing operations. Pipelines can disable the vanilla clear pass in pipeline config. Material shader authors note: this may not be the actual clear color used by the in-effect pipeline. (It might not clear with a single color at all!) const int frx_worldHasSkylight True when the currently rendering world has a sky with a light source. Zero otherwise. const int frx_worldIsOverworld Equals 1 when the currently rendering world is the Overworld. Zero otherwise. const int frx_worldIsNether Equals 1 when the currently rendering world is the Nether. Zero otherwise. const int frx_worldIsEnd Equals 1 when the currently rendering world is the End. Zero otherwise. const int frx_worldIsRaining Equals 1 when world.isRaining() is true for the currently rendering world. const int frx_worldIsThundering Bet you can guess. const int frx_worldIsSkyDarkened Equals 1 when world.getSkyProperties().isDarkened() is true for the currently rendering world. Zero otherwise. True (==1) in Nether - indicates diffuse lighting bottom face is same as top, not as bright. const int frx_worldIsMoonlit Equals 1 when the sky light modeled by frx_skyLightStrength and frx_skyLightVector is the moon. Zero otherwise. frx_conditionTest(int conditionIndex) [PROTOTYPE] Returns 1 when the condition is true, zero otherwise.","title":"world.h"},{"location":"api/world.h/#worldh","text":"Specifies the variables and methods available in the FREX shader API for access to world information. See FREX Shader API.md for license and general informaiton.","title":"world.h"},{"location":"api/world.h/#const-float-frx_renderseconds","text":"The number of seconds this world has been rendering since the last render reload, including fractional seconds. Use this for effects that need a smoothly increasing counter.","title":"const float frx_renderSeconds"},{"location":"api/world.h/#const-uint-frx_renderframes","text":"The number of frames this world has been rendering since the last render reload. Use this for effects that need a discrete increasing counter.","title":"const uint frx_renderFrames"},{"location":"api/world.h/#const-float-frx_worldday","text":"Day of the currently rendering world - integer portion only. This is the apparent day, not the elapsed play time, which can be different due to sleeping, /set time, etc. Use this for effects that depend somehow on the season or age of the world. Received from server - may not be smoothly incremented.","title":"const float frx_worldDay"},{"location":"api/world.h/#const-float-frx_worldtime","text":"Time of the currently rendering world with values 0 to 1. Zero represents the morning / start of the day cycle in Minecraft. Use this for effects that depend on the time of day. Received from server - may not be smoothly incremented.","title":"const float frx_worldTime"},{"location":"api/world.h/#const-float-frx_moonsize","text":"Size of the moon the currently rendering world. Values are 0 to 1.","title":"const float frx_moonSize"},{"location":"api/world.h/#const-float-frx_skyangleradians","text":"Rotation of the sky dome as part of the day/night cycle. Will not advance if doDaylightCycle game rule is turned off. In vanilla dimensions, zero represents the condition at tick = 0 (just after sunrise) and rotation is around the Z axis. Will be zero at noon, (world time = 6000) but vanilla adjusts the progression so that the sun is slightly over the horizon at world time = 0 and also takes its time setting as well.","title":"const float frx_skyAngleRadians"},{"location":"api/world.h/#const-vec3-frx_skylightvector","text":"Normalized vector of the primary sky light (the sun or moon) used for shadow mapping and useful for direct sky lighting. Points towards the skylight. Will not advance if doDaylightCycle game rule is turned off. See notes on frx_skyAngleRadians() regarding asymmetry.","title":"const vec3 frx_skyLightVector"},{"location":"api/world.h/#const-vec3-frx_skylightcolor","text":"Linear RGB color of the most prevalent sky light - the one that is used for shadow map and intended for directional lighting. Does not vary by time of day or for atmospheric effects but can vary based on season or other celestial variables for modded dimensions or if configured for vanilla dimensions. Not adjusted for night vision or any player effect. Does not account for underwater or any other occlusion. Not adjusted for rain, thunder, cloud cover, or lightning. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be unit vector if the world has no skylight.","title":"const vec3 frx_skyLightColor"},{"location":"api/world.h/#const-float-frx_skylightilluminance","text":"Measures intensity of direct sky light in lumens/square meter. (lux) Does not vary by time of day or for atmospheric effects but can vary based on season or other celestial variables for modded dimensions or if configured for vanilla dimensions. Also varies by moon phase for moonlight if that feature is enabled. Not adjusted for night vision or any player effect. Does not account for underwater or any other occlusion. Not adjusted for rain, thunder, cloud cover, or lightning. FREX pegs vanilla sunlight illuminace at 32,000 lux. Value could be different for modded dimensions or if configured via resource pack. Moonlight in Vanilla appears to be more intense than in the real world. If configured to mimic vanilla, moonlight will be ~100lux but can be very small or zero (or perhaps higher) in other configurations. Values assume an idealized, non-specific reference white light. When multiplied by frx_skyLightColor() the effective luminance will be somewhat less, but shaders are not expected to compensate for this. Most celestial light sources are some flavor of white, and stongly-colored lights can be handled by adjusting the illuminance in the mod/pack configuration if needed. Effective illuminance will also be reduced if light is multiplied by frx_skyLightAtmosphericColor() but that should not require any compensation because it mimics the scattering of light. Pipelines that strive for physical realism will not use that factor anyway. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be zero if the world has no skylight.","title":"const float frx_skyLightIlluminance"},{"location":"api/world.h/#const-vec3-frx_skylightatmosphericcolor","text":"Linear RGB color modifier for the most prevalent sky light - the one that is used for shadow map and intended for directional lighting. Also adjusted by time of day to account for atmospheric effects. Pipelines that model atmospheric scattering will not want this. Not adjusted for weather, lightning, night vision or any player effect. Does not account for underwater or any other occlusion. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be unit vector if the world has no skylight.","title":"const vec3 frx_skyLightAtmosphericColor"},{"location":"api/world.h/#const-float-frx_skylighttransitionfactor","text":"Smoothing factor to help with the transition from sun to/from moon light. Ramps down to zero down as the moon set and then back up to one as the sun rises. In future, will be configurable by dimension. Use the FRX_WORLD_IS_MOONLIT flag to query if this is sun or moonlight. Will be 1.0 (and mean nothing) if the world has no skylight.","title":"const float frx_skyLightTransitionFactor"},{"location":"api/world.h/#const-float-frx_skyflashstrength","text":"Strength of sky flashing during a lightning strike. Forms a reverse sawtooth pattern with random peaks over time. UNCLAMPED, but meant to be clamped to values between 0 and 1. HDR implementation might want to use values above 1 to represent stronger flashes. Locked to 0 if Accessibility Setting > Hide Lightning Flashes is ON.","title":"const float frx_skyFlashStrength"},{"location":"api/world.h/#const-float-frx_ambientintensity","text":"Ambient light intensity of the currently rendering world. Zero represents the morning / start of the day cycle in Minecraft. Experimental, likely to change.","title":"const float frx_ambientIntensity"},{"location":"api/world.h/#const-vec4-frx_emissivecolor","text":"Gamma-corrected max light color from lightmap texture. Updated whenever lightmap texture is updated. Multiply emissive outputs by this to be consistent with the game's brightness settings. Note that Canvas normally handles this automatically. It is exposed for exotic use cases.","title":"const vec4 frx_emissiveColor"},{"location":"api/world.h/#const-float-frx_raingradient","text":"MC rain strength. Values 0 to 1.","title":"const float frx_rainGradient"},{"location":"api/world.h/#const-float-frx_thundergradient","text":"MC thunder strength. Values 0 to 1.","title":"const float frx_thunderGradient"},{"location":"api/world.h/#const-float-frx_smoothedraingradient","text":"Same as frx_rainGradient but with exponential smoothing. Speed is controlled in pipeline config.","title":"const float frx_smoothedRainGradient"},{"location":"api/world.h/#const-float-frx_smoothedthundergradient","text":"Same as frx_thunderGradient but with exponential smoothing. Speed is controlled in pipeline config.","title":"const float frx_smoothedThunderGradient"},{"location":"api/world.h/#const-vec3-frx_vanillaclearcolor","text":"The background clear color as computed by vanilla logic. Incorporates many different factors. For use by pipelines that may want to modify and do their own clearing operations. Pipelines can disable the vanilla clear pass in pipeline config. Material shader authors note: this may not be the actual clear color used by the in-effect pipeline. (It might not clear with a single color at all!)","title":"const vec3 frx_vanillaClearColor"},{"location":"api/world.h/#const-int-frx_worldhasskylight","text":"True when the currently rendering world has a sky with a light source. Zero otherwise.","title":"const int frx_worldHasSkylight"},{"location":"api/world.h/#const-int-frx_worldisoverworld","text":"Equals 1 when the currently rendering world is the Overworld. Zero otherwise.","title":"const int frx_worldIsOverworld"},{"location":"api/world.h/#const-int-frx_worldisnether","text":"Equals 1 when the currently rendering world is the Nether. Zero otherwise.","title":"const int frx_worldIsNether"},{"location":"api/world.h/#const-int-frx_worldisend","text":"Equals 1 when the currently rendering world is the End. Zero otherwise.","title":"const int frx_worldIsEnd"},{"location":"api/world.h/#const-int-frx_worldisraining","text":"Equals 1 when world.isRaining() is true for the currently rendering world.","title":"const int frx_worldIsRaining"},{"location":"api/world.h/#const-int-frx_worldisthundering","text":"Bet you can guess.","title":"const int frx_worldIsThundering"},{"location":"api/world.h/#const-int-frx_worldisskydarkened","text":"Equals 1 when world.getSkyProperties().isDarkened() is true for the currently rendering world. Zero otherwise. True (==1) in Nether - indicates diffuse lighting bottom face is same as top, not as bright.","title":"const int frx_worldIsSkyDarkened"},{"location":"api/world.h/#const-int-frx_worldismoonlit","text":"Equals 1 when the sky light modeled by frx_skyLightStrength and frx_skyLightVector is the moon. Zero otherwise.","title":"const int frx_worldIsMoonlit"},{"location":"api/world.h/#frx_conditiontestint-conditionindex-prototype","text":"Returns 1 when the condition is true, zero otherwise.","title":"frx_conditionTest(int conditionIndex) [PROTOTYPE]"},{"location":"lib/bitwise.glsl/","text":"bitwise.glsl frex:shaders/lib/bitwise.glsl DEPRECATED - No longer useful now that we have reliable bitwide operations in GLSL. Preprocessor: #define frx_bitValue(byteValue, bitIndex) float((byteValue >> bitIndex) & 1u)","title":"bitwise.glsl"},{"location":"lib/bitwise.glsl/#bitwiseglsl","text":"frex:shaders/lib/bitwise.glsl DEPRECATED - No longer useful now that we have reliable bitwide operations in GLSL.","title":"bitwise.glsl"},{"location":"lib/bitwise.glsl/#preprocessor-define-frx_bitvaluebytevalue-bitindex-floatbytevalue-bitindex-1u","text":"","title":"Preprocessor: #define frx_bitValue(byteValue, bitIndex) float((byteValue &gt;&gt; bitIndex) &amp; 1u)"},{"location":"lib/color.glsl/","text":"color.glsl frex:shaders/lib/color.glsl Common color processing functions. Portions taken from Wisdom Shaders by Cheng (Bob) Cao, Apache 2.0 license https://github.com/bobcao3/Wisdom-Shaders Preprocessor: #define FRX_GAMMA 2.4 Preprocessor: #define FRX_INVERSE_GAMMA (1.0 / FRX_GAMMA) frx_fromGamma(vec4 c) { return pow(c, vec4(FRX_GAMMA)); } frx_toGamma(vec4 c) { return pow(c, vec4(FRX_INVERSE_GAMMA)); } frx_fromGamma(vec3 c) { return pow(c, vec3(FRX_GAMMA)); } frx_toGamma(vec3 c) { return pow(c, vec3(FRX_INVERSE_GAMMA)); } const mat3 FRX_ACES_INPUT_MATRIX = mat3 ( vec3 ( 0 . 5 9 7 1 9 , 0 . 0 7 6 0 0 , 0 . 0 2 8 4 0 ) , vec3 ( 0 . 3 5 4 5 8 , 0 . 9 0 8 3 4 , 0 . 1 3 3 8 3 ) , vec3 ( 0 . 0 4 8 2 3 , 0 . 0 1 5 6 6 , 0 . 8 3 7 7 7 ) ) float frx_luma(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); } const mat3 FRX_ACES_OUTPUT_MATRIX = mat3 ( vec3 ( 1 . 6 0 4 7 5 , -0 . 1 0 2 0 8 , -0 . 0 0 3 2 7 ) , vec3 ( -0 . 5 3 1 0 8 , 1 . 1 0 8 1 3 , -0 . 0 7 2 7 6 ) , vec3 ( -0 . 0 7 3 6 7 , -0 . 0 0 6 0 5 , 1 . 0 7 6 0 2 ) ) ODT_SAT => XYZ => D60_2_D65 => sRGB FRX_RRT_AND_ODTF_FIT(vec3 v) { vec3 a = v * (v + 0.0245786f) - 0.000090537f; vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f; return a / b; } frx_toneMap(vec3 color) { color = FRX_ACES_INPUT_MATRIX * color; color = FRX_RRT_AND_ODTF_FIT(color); return FRX_ACES_OUTPUT_MATRIX * color; }","title":"color.glsl"},{"location":"lib/color.glsl/#colorglsl","text":"frex:shaders/lib/color.glsl Common color processing functions. Portions taken from Wisdom Shaders by Cheng (Bob) Cao, Apache 2.0 license https://github.com/bobcao3/Wisdom-Shaders","title":"color.glsl"},{"location":"lib/color.glsl/#preprocessor-define-frx_gamma-24","text":"","title":"Preprocessor: #define FRX_GAMMA 2.4"},{"location":"lib/color.glsl/#preprocessor-define-frx_inverse_gamma-10-frx_gamma","text":"","title":"Preprocessor: #define FRX_INVERSE_GAMMA (1.0 / FRX_GAMMA)"},{"location":"lib/color.glsl/#frx_fromgammavec4-c","text":"{ return pow(c, vec4(FRX_GAMMA)); }","title":"frx_fromGamma(vec4 c)"},{"location":"lib/color.glsl/#frx_togammavec4-c","text":"{ return pow(c, vec4(FRX_INVERSE_GAMMA)); }","title":"frx_toGamma(vec4 c)"},{"location":"lib/color.glsl/#frx_fromgammavec3-c","text":"{ return pow(c, vec3(FRX_GAMMA)); }","title":"frx_fromGamma(vec3 c)"},{"location":"lib/color.glsl/#frx_togammavec3-c","text":"{ return pow(c, vec3(FRX_INVERSE_GAMMA)); }","title":"frx_toGamma(vec3 c)"},{"location":"lib/color.glsl/#const-mat3-frx_aces_input_matrix-mat3-vec3-0-5-9-7-1-9-0-0-7-6-0-0-0-0-2-8-4-0-vec3-0-3-5-4-5-8-0-9-0-8-3-4-0-1-3-3-8-3-vec3-0-0-4-8-2-3-0-0-1-5-6-6-0-8-3-7-7-7","text":"float frx_luma(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); }","title":"const mat3 FRX_ACES_INPUT_MATRIX = mat3 ( vec3 ( 0 . 5 9 7 1 9 , 0 . 0 7 6 0 0 , 0 . 0 2 8 4 0 ) , vec3 ( 0 . 3 5 4 5 8 , 0 . 9 0 8 3 4 , 0 . 1 3 3 8 3 ) , vec3 ( 0 . 0 4 8 2 3 , 0 . 0 1 5 6 6 , 0 . 8 3 7 7 7 ) )"},{"location":"lib/color.glsl/#const-mat3-frx_aces_output_matrix-mat3-vec3-1-6-0-4-7-5-0-1-0-2-0-8-0-0-0-3-2-7-vec3-0-5-3-1-0-8-1-1-0-8-1-3-0-0-7-2-7-6-vec3-0-0-7-3-6-7-0-0-0-6-0-5-1-0-7-6-0-2","text":"ODT_SAT => XYZ => D60_2_D65 => sRGB","title":"const mat3 FRX_ACES_OUTPUT_MATRIX = mat3 ( vec3 ( 1 . 6 0 4 7 5 , -0 . 1 0 2 0 8 , -0 . 0 0 3 2 7 ) , vec3 ( -0 . 5 3 1 0 8 , 1 . 1 0 8 1 3 , -0 . 0 7 2 7 6 ) , vec3 ( -0 . 0 7 3 6 7 , -0 . 0 0 6 0 5 , 1 . 0 7 6 0 2 ) )"},{"location":"lib/color.glsl/#frx_rrt_and_odtf_fitvec3-v","text":"{ vec3 a = v * (v + 0.0245786f) - 0.000090537f; vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f; return a / b; }","title":"FRX_RRT_AND_ODTF_FIT(vec3 v)"},{"location":"lib/color.glsl/#frx_tonemapvec3-color","text":"{ color = FRX_ACES_INPUT_MATRIX * color; color = FRX_RRT_AND_ODTF_FIT(color); return FRX_ACES_OUTPUT_MATRIX * color; }","title":"frx_toneMap(vec3 color)"},{"location":"lib/face.glsl/","text":"face.glsl frex:shaders/lib/face.glsl Utilities for deriving facing and face-related attributes. Preprocessor: #define FACE_DOWN 0 Preprocessor: #define FACE_UP 1 Preprocessor: #define FACE_NORTH 2 Preprocessor: #define FACE_SOUTH 3 Preprocessor: #define FACE_WEST 4 Preprocessor: #define FACE_EAST 5 UNKNOWN STATEMENT const mat3 [ 6 ] FRX_UV_MATRIX = mat3 [ 6 ] ( mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 ) ) ; frx_face(vec3 normal) Returns the FACE_ constant most consistent with the provided world-space normal. Will return garbage for normals in screen space. { vec3 a = abs(normal); float m = max(max(a.x, a.y), a.z); return a.x == m ? (normal.x > 0 ? FACE_EAST : FACE_WEST) : a.y == m ? (normal.y > 0 ? FACE_UP : FACE_DOWN) : (normal.z > 0 ? FACE_SOUTH : FACE_NORTH); } frx_faceUv(vec3 pos, vec3 normal) Estimates UV coordinates for a world-space position and world-space normal, assuming texture coordinates are from the 0,0 face corner to the opposite corner. The result is similar to \"locked-uv\" coordinate mapping in block/item models. Will return garbage for vertex or normals in screen space. { mat3 m = FRX_UV_MATRIX[frx_face(normal)]; vec3 result = m * pos; return result.xy; } frx_faceUv(vec3 pos, int face) Estimates UV coordinates for a world-space position and world-space normal, assuming texture coordinates are from the 0,0 face corner to the opposite corner. The result is similar to \"locked-uv\" coordinate mapping in block/item models. Will return garbage for vertex or normals in screen space. { mat3 m = FRX_UV_MATRIX[face]; vec3 result = m * pos; return result.xy; }","title":"face.glsl"},{"location":"lib/face.glsl/#faceglsl","text":"frex:shaders/lib/face.glsl Utilities for deriving facing and face-related attributes.","title":"face.glsl"},{"location":"lib/face.glsl/#preprocessor-define-face_down-0","text":"","title":"Preprocessor: #define FACE_DOWN 0"},{"location":"lib/face.glsl/#preprocessor-define-face_up-1","text":"","title":"Preprocessor: #define FACE_UP 1"},{"location":"lib/face.glsl/#preprocessor-define-face_north-2","text":"","title":"Preprocessor: #define FACE_NORTH 2"},{"location":"lib/face.glsl/#preprocessor-define-face_south-3","text":"","title":"Preprocessor: #define FACE_SOUTH 3"},{"location":"lib/face.glsl/#preprocessor-define-face_west-4","text":"","title":"Preprocessor: #define FACE_WEST 4"},{"location":"lib/face.glsl/#preprocessor-define-face_east-5","text":"","title":"Preprocessor: #define FACE_EAST 5"},{"location":"lib/face.glsl/#unknown-statement-const-mat3-6-frx_uv_matrix-mat3-6-mat3-1-0-0-0-0-0-0-0-0-0-0-0-0-0-1-0-0-0-mat3-1-0-0-0-0-0-0-0-0-0-0-0-0-0-1-0-0-0-mat3-1-0-0-0-0-0-0-0-1-0-0-0-0-0-0-0-0-0-mat3-1-0-0-0-0-0-0-0-1-0-0-0-0-0-0-0-0-0-mat3-0-0-0-0-0-0-0-0-1-0-0-0-1-0-0-0-0-0-mat3-0-0-0-0-0-0-0-0-1-0-0-0-1-0-0-0-0-0","text":"","title":"UNKNOWN STATEMENT const mat3 [ 6 ] FRX_UV_MATRIX = mat3 [ 6 ] ( mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 ) , mat3 ( 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 1 . 0 , 0 . 0 , 0 . 0 ) ) ;"},{"location":"lib/face.glsl/#frx_facevec3-normal","text":"Returns the FACE_ constant most consistent with the provided world-space normal. Will return garbage for normals in screen space. { vec3 a = abs(normal); float m = max(max(a.x, a.y), a.z); return a.x == m ? (normal.x > 0 ? FACE_EAST : FACE_WEST) : a.y == m ? (normal.y > 0 ? FACE_UP : FACE_DOWN) : (normal.z > 0 ? FACE_SOUTH : FACE_NORTH); }","title":"frx_face(vec3 normal)"},{"location":"lib/face.glsl/#frx_faceuvvec3-pos-vec3-normal","text":"Estimates UV coordinates for a world-space position and world-space normal, assuming texture coordinates are from the 0,0 face corner to the opposite corner. The result is similar to \"locked-uv\" coordinate mapping in block/item models. Will return garbage for vertex or normals in screen space. { mat3 m = FRX_UV_MATRIX[frx_face(normal)]; vec3 result = m * pos; return result.xy; }","title":"frx_faceUv(vec3 pos, vec3 normal)"},{"location":"lib/face.glsl/#frx_faceuvvec3-pos-int-face","text":"Estimates UV coordinates for a world-space position and world-space normal, assuming texture coordinates are from the 0,0 face corner to the opposite corner. The result is similar to \"locked-uv\" coordinate mapping in block/item models. Will return garbage for vertex or normals in screen space. { mat3 m = FRX_UV_MATRIX[face]; vec3 result = m * pos; return result.xy; }","title":"frx_faceUv(vec3 pos, int face)"},{"location":"lib/math.glsl/","text":"math.glsl frex:shaders/lib/math.glsl Commonly useful declarations and utilities. Use of these is entirely optional - half the fun is making your own. Preprocessor: #define PI 3.1415926535897932384626433832795 Preprocessor: #define HALF_PI 1.57079632679489661923 // I prefer a whole pi when I can get it, but I won't say no to half. Preprocessor: #define TAU 6.2831853071795864769252867665590 // two PI frx_noise2d(vec2 st) Has been around forever. Gives a psuedorandom hash value given two variables. Wouldn't be OK for cryptography but may get the job done here. https://thebookofshaders.com/10/ https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner { return fract(sin(dot(st.xy, vec2(12.9898, 78.233)))*43758.5453123); } frx_smootherstep(float edge0, float edge1, float x) Ken Perlin's improved smoothstep { // Scale, and clamp to 0..1 range x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); // Evaluate polynomial return x * x * x * (x * (x * 6 - 15) + 10); } frx_smootherstep(float edge0, float edge1, vec3 value) Ken Perlin's improved smoothstep { // Scale, and clamp to 0..1 range vec3 r = clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0); // Evaluate polynomial return r * r * r * (r * (r * 6 - 15) + 10); } frx_noise2dt(in vec2 st, float t) Animated 2d noise function, designed to accept a time parameter. Based in part on 2D Noise by Morgan McGuire @morgan3d https://www.shadertoy.com/view/4dS3Wd { vec2 i = floor(st); vec2 f = fract(st); // Compute values for four corners float a = frx_noise2d(i); float b = frx_noise2d(i + vec2(1.0, 0.0)); float c = frx_noise2d(i + vec2(0.0, 1.0)); float d = frx_noise2d(i + vec2(1.0, 1.0)); a = 0.5 + sin((0.5 + a) * t) * 0.5; b = 0.5 + sin((0.5 + b) * t) * 0.5; c = 0.5 + sin((0.5 + c) * t) * 0.5; d = 0.5 + sin((0.5 + d) * t) * 0.5; // Mix 4 corners return mix(a, b, f.x) + (c - a)* f.y * (1.0 - f.x) + (d - b) * f.x * f.y; } frx_luminance(vec3 color) Converts RGB to grayscale. { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }","title":"math.glsl"},{"location":"lib/math.glsl/#mathglsl","text":"frex:shaders/lib/math.glsl Commonly useful declarations and utilities. Use of these is entirely optional - half the fun is making your own.","title":"math.glsl"},{"location":"lib/math.glsl/#preprocessor-define-pi-31415926535897932384626433832795","text":"","title":"Preprocessor: #define PI 3.1415926535897932384626433832795"},{"location":"lib/math.glsl/#preprocessor-define-half_pi-157079632679489661923-i-prefer-a-whole-pi-when-i-can-get-it-but-i-wont-say-no-to-half","text":"","title":"Preprocessor: #define HALF_PI 1.57079632679489661923 // I prefer a whole pi when I can get it, but I won't say no to half."},{"location":"lib/math.glsl/#preprocessor-define-tau-62831853071795864769252867665590-two-pi","text":"","title":"Preprocessor: #define TAU 6.2831853071795864769252867665590 // two PI"},{"location":"lib/math.glsl/#frx_noise2dvec2-st","text":"Has been around forever. Gives a psuedorandom hash value given two variables. Wouldn't be OK for cryptography but may get the job done here. https://thebookofshaders.com/10/ https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner { return fract(sin(dot(st.xy, vec2(12.9898, 78.233)))*43758.5453123); }","title":"frx_noise2d(vec2 st)"},{"location":"lib/math.glsl/#frx_smootherstepfloat-edge0-float-edge1-float-x","text":"Ken Perlin's improved smoothstep { // Scale, and clamp to 0..1 range x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); // Evaluate polynomial return x * x * x * (x * (x * 6 - 15) + 10); }","title":"frx_smootherstep(float edge0, float edge1, float x)"},{"location":"lib/math.glsl/#frx_smootherstepfloat-edge0-float-edge1-vec3-value","text":"Ken Perlin's improved smoothstep { // Scale, and clamp to 0..1 range vec3 r = clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0); // Evaluate polynomial return r * r * r * (r * (r * 6 - 15) + 10); }","title":"frx_smootherstep(float edge0, float edge1, vec3 value)"},{"location":"lib/math.glsl/#frx_noise2dtin-vec2-st-float-t","text":"Animated 2d noise function, designed to accept a time parameter. Based in part on 2D Noise by Morgan McGuire @morgan3d https://www.shadertoy.com/view/4dS3Wd { vec2 i = floor(st); vec2 f = fract(st); // Compute values for four corners float a = frx_noise2d(i); float b = frx_noise2d(i + vec2(1.0, 0.0)); float c = frx_noise2d(i + vec2(0.0, 1.0)); float d = frx_noise2d(i + vec2(1.0, 1.0)); a = 0.5 + sin((0.5 + a) * t) * 0.5; b = 0.5 + sin((0.5 + b) * t) * 0.5; c = 0.5 + sin((0.5 + c) * t) * 0.5; d = 0.5 + sin((0.5 + d) * t) * 0.5; // Mix 4 corners return mix(a, b, f.x) + (c - a)* f.y * (1.0 - f.x) + (d - b) * f.x * f.y; }","title":"frx_noise2dt(in vec2 st, float t)"},{"location":"lib/math.glsl/#frx_luminancevec3-color","text":"Converts RGB to grayscale. { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }","title":"frx_luminance(vec3 color)"},{"location":"lib/sample.glsl/","text":"sample.glsl frex:shaders/lib/sample.glsl Common sampling functions. frx_sample13(sampler2D tex, vec2 uv, vec2 distance, int lod) Temporally stable box filter, as described by Jorge Jiminez, 2014 http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare { vec4 a = textureLod(tex, uv + distance * vec2(-1.0, -1.0), lod); vec4 b = textureLod(tex, uv + distance * vec2(0.0, -1.0), lod); vec4 c = textureLod(tex, uv + distance * vec2(1.0, -1.0), lod); vec4 d = textureLod(tex, uv + distance * vec2(-0.5, -0.5), lod); vec4 e = textureLod(tex, uv + distance * vec2(0.5, -0.5), lod); vec4 f = textureLod(tex, uv + distance * vec2(-1.0, 0.0), lod); vec4 g = textureLod(tex, uv, lod); vec4 h = textureLod(tex, uv + distance * vec2(1.0, 0.0), lod); vec4 i = textureLod(tex, uv + distance * vec2(-0.5, 0.5), lod); vec4 j = textureLod(tex, uv + distance * vec2(0.5, 0.5), lod); vec4 k = textureLod(tex, uv + distance * vec2(-1.0, 1.0), lod); vec4 l = textureLod(tex, uv + distance * vec2(0.0, 1.0), lod); vec4 m = textureLod(tex, uv + distance * vec2(1.0, 1.0), lod); vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125); vec4 o = (d + e + i + j) * div.x; o += (a + b + g + f) * div.y; o += (b + c + h + g) * div.y; o += (f + g + l + k) * div.y; o += (g + h + m + l) * div.y; return o; } frx_sample13(sampler2D tex, vec2 uv, vec2 distance) non-LOD version of above { vec4 a = texture(tex, uv + distance * vec2(-1.0, -1.0)); vec4 b = texture(tex, uv + distance * vec2(0.0, -1.0)); vec4 c = texture(tex, uv + distance * vec2(1.0, -1.0)); vec4 d = texture(tex, uv + distance * vec2(-0.5, -0.5)); vec4 e = texture(tex, uv + distance * vec2(0.5, -0.5)); vec4 f = texture(tex, uv + distance * vec2(-1.0, 0.0)); vec4 g = texture(tex, uv); vec4 h = texture(tex, uv + distance * vec2(1.0, 0.0)); vec4 i = texture(tex, uv + distance * vec2(-0.5, 0.5)); vec4 j = texture(tex, uv + distance * vec2(0.5, 0.5)); vec4 k = texture(tex, uv + distance * vec2(-1.0, 1.0)); vec4 l = texture(tex, uv + distance * vec2(0.0, 1.0)); vec4 m = texture(tex, uv + distance * vec2(1.0, 1.0)); vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125); vec4 o = (d + e + i + j) * div.x; o += (a + b + g + f) * div.y; o += (b + c + h + g) * div.y; o += (f + g + l + k) * div.y; o += (g + h + m + l) * div.y; return o; } frx_sampleTent(sampler2D tex, vec2 uv, vec2 distance, int lod) Used for bloom upsample, as described by Jorge Jiminez, 2014 http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare { vec4 d = distance.xyxy * vec4(1.0, 1.0, -1.0, 0.0); vec4 sum = textureLod(tex, uv - d.xy, lod) + textureLod(tex, uv - d.wy, lod) * 2.0 + textureLod(tex, uv - d.zy, lod) + textureLod(tex, uv + d.zw, lod) * 2.0 + textureLod(tex, uv, lod) * 4.0 + textureLod(tex, uv + d.xw, lod) * 2.0 + textureLod(tex, uv + d.zy, lod) + textureLod(tex, uv + d.wy, lod) * 2.0 + textureLod(tex, uv + d.xy, lod); return sum * (1.0 / 16.0); } frx_sampleTent(sampler2D tex, vec2 uv, vec2 distance) non-LOD version of above { vec4 d = distance.xyxy * vec4(1.0, 1.0, -1.0, 0.0); vec4 sum = texture(tex, uv - d.xy) + texture(tex, uv - d.wy) * 2.0 + texture(tex, uv - d.zy) + texture(tex, uv + d.zw) * 2.0 + texture(tex, uv) * 4.0 + texture(tex, uv + d.xw) * 2.0 + texture(tex, uv + d.zy) + texture(tex, uv + d.wy) * 2.0 + texture(tex, uv + d.xy); return sum * (1.0 / 16.0); }","title":"sample.glsl"},{"location":"lib/sample.glsl/#sampleglsl","text":"frex:shaders/lib/sample.glsl Common sampling functions.","title":"sample.glsl"},{"location":"lib/sample.glsl/#frx_sample13sampler2d-tex-vec2-uv-vec2-distance-int-lod","text":"Temporally stable box filter, as described by Jorge Jiminez, 2014 http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare { vec4 a = textureLod(tex, uv + distance * vec2(-1.0, -1.0), lod); vec4 b = textureLod(tex, uv + distance * vec2(0.0, -1.0), lod); vec4 c = textureLod(tex, uv + distance * vec2(1.0, -1.0), lod); vec4 d = textureLod(tex, uv + distance * vec2(-0.5, -0.5), lod); vec4 e = textureLod(tex, uv + distance * vec2(0.5, -0.5), lod); vec4 f = textureLod(tex, uv + distance * vec2(-1.0, 0.0), lod); vec4 g = textureLod(tex, uv, lod); vec4 h = textureLod(tex, uv + distance * vec2(1.0, 0.0), lod); vec4 i = textureLod(tex, uv + distance * vec2(-0.5, 0.5), lod); vec4 j = textureLod(tex, uv + distance * vec2(0.5, 0.5), lod); vec4 k = textureLod(tex, uv + distance * vec2(-1.0, 1.0), lod); vec4 l = textureLod(tex, uv + distance * vec2(0.0, 1.0), lod); vec4 m = textureLod(tex, uv + distance * vec2(1.0, 1.0), lod); vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125); vec4 o = (d + e + i + j) * div.x; o += (a + b + g + f) * div.y; o += (b + c + h + g) * div.y; o += (f + g + l + k) * div.y; o += (g + h + m + l) * div.y; return o; }","title":"frx_sample13(sampler2D tex, vec2 uv, vec2 distance, int lod)"},{"location":"lib/sample.glsl/#frx_sample13sampler2d-tex-vec2-uv-vec2-distance","text":"non-LOD version of above { vec4 a = texture(tex, uv + distance * vec2(-1.0, -1.0)); vec4 b = texture(tex, uv + distance * vec2(0.0, -1.0)); vec4 c = texture(tex, uv + distance * vec2(1.0, -1.0)); vec4 d = texture(tex, uv + distance * vec2(-0.5, -0.5)); vec4 e = texture(tex, uv + distance * vec2(0.5, -0.5)); vec4 f = texture(tex, uv + distance * vec2(-1.0, 0.0)); vec4 g = texture(tex, uv); vec4 h = texture(tex, uv + distance * vec2(1.0, 0.0)); vec4 i = texture(tex, uv + distance * vec2(-0.5, 0.5)); vec4 j = texture(tex, uv + distance * vec2(0.5, 0.5)); vec4 k = texture(tex, uv + distance * vec2(-1.0, 1.0)); vec4 l = texture(tex, uv + distance * vec2(0.0, 1.0)); vec4 m = texture(tex, uv + distance * vec2(1.0, 1.0)); vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125); vec4 o = (d + e + i + j) * div.x; o += (a + b + g + f) * div.y; o += (b + c + h + g) * div.y; o += (f + g + l + k) * div.y; o += (g + h + m + l) * div.y; return o; }","title":"frx_sample13(sampler2D tex, vec2 uv, vec2 distance)"},{"location":"lib/sample.glsl/#frx_sampletentsampler2d-tex-vec2-uv-vec2-distance-int-lod","text":"Used for bloom upsample, as described by Jorge Jiminez, 2014 http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare { vec4 d = distance.xyxy * vec4(1.0, 1.0, -1.0, 0.0); vec4 sum = textureLod(tex, uv - d.xy, lod) + textureLod(tex, uv - d.wy, lod) * 2.0 + textureLod(tex, uv - d.zy, lod) + textureLod(tex, uv + d.zw, lod) * 2.0 + textureLod(tex, uv, lod) * 4.0 + textureLod(tex, uv + d.xw, lod) * 2.0 + textureLod(tex, uv + d.zy, lod) + textureLod(tex, uv + d.wy, lod) * 2.0 + textureLod(tex, uv + d.xy, lod); return sum * (1.0 / 16.0); }","title":"frx_sampleTent(sampler2D tex, vec2 uv, vec2 distance, int lod)"},{"location":"lib/sample.glsl/#frx_sampletentsampler2d-tex-vec2-uv-vec2-distance","text":"non-LOD version of above { vec4 d = distance.xyxy * vec4(1.0, 1.0, -1.0, 0.0); vec4 sum = texture(tex, uv - d.xy) + texture(tex, uv - d.wy) * 2.0 + texture(tex, uv - d.zy) + texture(tex, uv + d.zw) * 2.0 + texture(tex, uv) * 4.0 + texture(tex, uv + d.xw) * 2.0 + texture(tex, uv + d.zy) + texture(tex, uv + d.wy) * 2.0 + texture(tex, uv + d.xy); return sum * (1.0 / 16.0); }","title":"frx_sampleTent(sampler2D tex, vec2 uv, vec2 distance)"},{"location":"lib/noise/cellular2d.glsl/","text":"cellular2d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl cellular(vec2 P) frex:shaders/lib/noise/cellular2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 2D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Standard 3x3 search window for good F1 and F2 values { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 3/7 #define jitter 1.0// Less gives more regular pattern vec2 Pi = mod289(floor(P)); vec2 Pf = fract(P); vec3 oi = vec3(-1.0, 0.0, 1.0); vec3 of = vec3(-0.5, 0.5, 1.5); vec3 px = permute(Pi.x + oi); vec3 p = permute(px.x + Pi.y + oi);// p11, p12, p13 vec3 ox = fract(p*K) - Ko; vec3 oy = mod7(floor(p*K))*K - Ko; vec3 dx = Pf.x + 0.5 + jitter*ox; vec3 dy = Pf.y - of + jitter*oy; vec3 d1 = dx * dx + dy * dy;// d11, d12 and d13, squared p = permute(px.y + Pi.y + oi);// p21, p22, p23 ox = fract(p*K) - Ko; oy = mod7(floor(p*K))*K - Ko; dx = Pf.x - 0.5 + jitter*ox; dy = Pf.y - of + jitter*oy; vec3 d2 = dx * dx + dy * dy;// d21, d22 and d23, squared p = permute(px.z + Pi.y + oi);// p31, p32, p33 ox = fract(p*K) - Ko; oy = mod7(floor(p*K))*K - Ko; dx = Pf.x - 1.5 + jitter*ox; dy = Pf.y - of + jitter*oy; vec3 d3 = dx * dx + dy * dy;// d31, d32 and d33, squared // Sort out the two smallest distances (F1, F2) vec3 d1a = min(d1, d2); d2 = max(d1, d2);// Swap to keep candidates for F2 d2 = min(d2, d3);// neither F1 nor F2 are now in d3 d1 = min(d1a, d2);// F1 is now in d1 d2 = max(d1a, d2);// Swap to keep candidates for F2 d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx;// Swap if smaller d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx;// F1 is in d1.x d1.yz = min(d1.yz, d2.yz);// F2 is now not in d2.yz d1.y = min(d1.y, d1.z);// nor in d1.z d1.y = min(d1.y, d2.x);// F2 is in d1.y, we're done. return sqrt(d1.xy); }","title":"cellular2d.glsl"},{"location":"lib/noise/cellular2d.glsl/#cellular2dglsl","text":"","title":"cellular2d.glsl"},{"location":"lib/noise/cellular2d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/cellular2d.glsl/#cellularvec2-p","text":"frex:shaders/lib/noise/cellular2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 2D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Standard 3x3 search window for good F1 and F2 values { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 3/7 #define jitter 1.0// Less gives more regular pattern vec2 Pi = mod289(floor(P)); vec2 Pf = fract(P); vec3 oi = vec3(-1.0, 0.0, 1.0); vec3 of = vec3(-0.5, 0.5, 1.5); vec3 px = permute(Pi.x + oi); vec3 p = permute(px.x + Pi.y + oi);// p11, p12, p13 vec3 ox = fract(p*K) - Ko; vec3 oy = mod7(floor(p*K))*K - Ko; vec3 dx = Pf.x + 0.5 + jitter*ox; vec3 dy = Pf.y - of + jitter*oy; vec3 d1 = dx * dx + dy * dy;// d11, d12 and d13, squared p = permute(px.y + Pi.y + oi);// p21, p22, p23 ox = fract(p*K) - Ko; oy = mod7(floor(p*K))*K - Ko; dx = Pf.x - 0.5 + jitter*ox; dy = Pf.y - of + jitter*oy; vec3 d2 = dx * dx + dy * dy;// d21, d22 and d23, squared p = permute(px.z + Pi.y + oi);// p31, p32, p33 ox = fract(p*K) - Ko; oy = mod7(floor(p*K))*K - Ko; dx = Pf.x - 1.5 + jitter*ox; dy = Pf.y - of + jitter*oy; vec3 d3 = dx * dx + dy * dy;// d31, d32 and d33, squared // Sort out the two smallest distances (F1, F2) vec3 d1a = min(d1, d2); d2 = max(d1, d2);// Swap to keep candidates for F2 d2 = min(d2, d3);// neither F1 nor F2 are now in d3 d1 = min(d1a, d2);// F1 is now in d1 d2 = max(d1a, d2);// Swap to keep candidates for F2 d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx;// Swap if smaller d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx;// F1 is in d1.x d1.yz = min(d1.yz, d2.yz);// F2 is now not in d2.yz d1.y = min(d1.y, d1.z);// nor in d1.z d1.y = min(d1.y, d2.x);// F2 is in d1.y, we're done. return sqrt(d1.xy); }","title":"cellular(vec2 P)"},{"location":"lib/noise/cellular2x2.glsl/","text":"cellular2x2.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl cellular2x2(vec2 P) frex:shaders/lib/noise/cellular2x2.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 2D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Speeded up by using 2x2 search window instead of 3x3, at the expense of some strong pattern artifacts. F2 is often wrong and has sharp discontinuities. If you need a smooth F2, use the slower 3x3 version. F1 is sometimes wrong, too, but OK for most purposes. { #define K 0.142857142857// 1/7 #define K2 0.0714285714285// K/2 #define jitter 0.8// jitter 1.0 makes F1 wrong more often vec2 Pi = mod289(floor(P)); vec2 Pf = fract(P); vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5); vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5); vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0)); p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0)); vec4 ox = mod7(p)*K+K2; vec4 oy = mod7(floor(p*K))*K+K2; vec4 dx = Pfx + jitter*ox; vec4 dy = Pfy + jitter*oy; vec4 d = dx * dx + dy * dy;// d11, d12, d21 and d22, squared // Sort out the two smallest distances #if 0 // Cheat and pick only F1 d.xy = min(d.xy, d.zw); d.x = min(d.x, d.y); return vec2(sqrt(d.x));// F1 duplicated, F2 not computed #else // Do it right and find both F1 and F2 d.xy = (d.x < d.y) ? d.xy : d.yx;// Swap if smaller d.xz = (d.x < d.z) ? d.xz : d.zx; d.xw = (d.x < d.w) ? d.xw : d.wx; d.y = min(d.y, d.z); d.y = min(d.y, d.w); return sqrt(d.xy); #endif }","title":"cellular2x2.glsl"},{"location":"lib/noise/cellular2x2.glsl/#cellular2x2glsl","text":"","title":"cellular2x2.glsl"},{"location":"lib/noise/cellular2x2.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/cellular2x2.glsl/#cellular2x2vec2-p","text":"frex:shaders/lib/noise/cellular2x2.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 2D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Speeded up by using 2x2 search window instead of 3x3, at the expense of some strong pattern artifacts. F2 is often wrong and has sharp discontinuities. If you need a smooth F2, use the slower 3x3 version. F1 is sometimes wrong, too, but OK for most purposes. { #define K 0.142857142857// 1/7 #define K2 0.0714285714285// K/2 #define jitter 0.8// jitter 1.0 makes F1 wrong more often vec2 Pi = mod289(floor(P)); vec2 Pf = fract(P); vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5); vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5); vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0)); p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0)); vec4 ox = mod7(p)*K+K2; vec4 oy = mod7(floor(p*K))*K+K2; vec4 dx = Pfx + jitter*ox; vec4 dy = Pfy + jitter*oy; vec4 d = dx * dx + dy * dy;// d11, d12, d21 and d22, squared // Sort out the two smallest distances #if 0 // Cheat and pick only F1 d.xy = min(d.xy, d.zw); d.x = min(d.x, d.y); return vec2(sqrt(d.x));// F1 duplicated, F2 not computed #else // Do it right and find both F1 and F2 d.xy = (d.x < d.y) ? d.xy : d.yx;// Swap if smaller d.xz = (d.x < d.z) ? d.xz : d.zx; d.xw = (d.x < d.w) ? d.xw : d.wx; d.y = min(d.y, d.z); d.y = min(d.y, d.w); return sqrt(d.xy); #endif }","title":"cellular2x2(vec2 P)"},{"location":"lib/noise/cellular2x2x2.glsl/","text":"cellular2x2x2.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl cellular2x2x2(vec3 P) frex:shaders/lib/noise/cellular2x2x2.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 3D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Speeded up by using 2x2x2 search window instead of 3x3x3, at the expense of some pattern artifacts. F2 is often wrong and has sharp discontinuities. If you need a good F2, use the slower 3x3x3 version. { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 1/2-K/2 #define K2 0.020408163265306// 1/(7*7) #define Kz 0.166666666667// 1/6 #define Kzo 0.416666666667// 1/2-1/6*2 #define jitter 0.8// smaller jitter gives less errors in F2 vec3 Pi = mod289(floor(P)); vec3 Pf = fract(P); vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0); vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0); vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0)); p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0)); vec4 p1 = permute(p + Pi.z);// z+0 vec4 p2 = permute(p + Pi.z + vec4(1.0));// z+1 vec4 ox1 = fract(p1*K) - Ko; vec4 oy1 = mod7(floor(p1*K))*K - Ko; vec4 oz1 = floor(p1*K2)*Kz - Kzo;// p1 < 289 guaranteed vec4 ox2 = fract(p2*K) - Ko; vec4 oy2 = mod7(floor(p2*K))*K - Ko; vec4 oz2 = floor(p2*K2)*Kz - Kzo; vec4 dx1 = Pfx + jitter*ox1; vec4 dy1 = Pfy + jitter*oy1; vec4 dz1 = Pf.z + jitter*oz1; vec4 dx2 = Pfx + jitter*ox2; vec4 dy2 = Pfy + jitter*oy2; vec4 dz2 = Pf.z - 1.0 + jitter*oz2; vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;// z+0 vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;// z+1 // Sort out the two smallest distances (F1, F2) #if 0 // Cheat and sort out only F1 d1 = min(d1, d2); d1.xy = min(d1.xy, d1.wz); d1.x = min(d1.x, d1.y); return vec2(sqrt(d1.x)); #else // Do it right and sort out both F1 and F2 vec4 d = min(d1, d2);// F1 is now in d d2 = max(d1, d2);// Make sure we keep all candidates for F2 d.xy = (d.x < d.y) ? d.xy : d.yx;// Swap smallest to d.x d.xz = (d.x < d.z) ? d.xz : d.zx; d.xw = (d.x < d.w) ? d.xw : d.wx;// F1 is now in d.x d.yzw = min(d.yzw, d2.yzw);// F2 now not in d2.yzw d.y = min(d.y, d.z);// nor in d.z d.y = min(d.y, d.w);// nor in d.w d.y = min(d.y, d2.x);// F2 is now in d.y return sqrt(d.xy);// F1 and F2 #endif }","title":"cellular2x2x2.glsl"},{"location":"lib/noise/cellular2x2x2.glsl/#cellular2x2x2glsl","text":"","title":"cellular2x2x2.glsl"},{"location":"lib/noise/cellular2x2x2.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/cellular2x2x2.glsl/#cellular2x2x2vec3-p","text":"frex:shaders/lib/noise/cellular2x2x2.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 3D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. Speeded up by using 2x2x2 search window instead of 3x3x3, at the expense of some pattern artifacts. F2 is often wrong and has sharp discontinuities. If you need a good F2, use the slower 3x3x3 version. { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 1/2-K/2 #define K2 0.020408163265306// 1/(7*7) #define Kz 0.166666666667// 1/6 #define Kzo 0.416666666667// 1/2-1/6*2 #define jitter 0.8// smaller jitter gives less errors in F2 vec3 Pi = mod289(floor(P)); vec3 Pf = fract(P); vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0); vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0); vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0)); p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0)); vec4 p1 = permute(p + Pi.z);// z+0 vec4 p2 = permute(p + Pi.z + vec4(1.0));// z+1 vec4 ox1 = fract(p1*K) - Ko; vec4 oy1 = mod7(floor(p1*K))*K - Ko; vec4 oz1 = floor(p1*K2)*Kz - Kzo;// p1 < 289 guaranteed vec4 ox2 = fract(p2*K) - Ko; vec4 oy2 = mod7(floor(p2*K))*K - Ko; vec4 oz2 = floor(p2*K2)*Kz - Kzo; vec4 dx1 = Pfx + jitter*ox1; vec4 dy1 = Pfy + jitter*oy1; vec4 dz1 = Pf.z + jitter*oz1; vec4 dx2 = Pfx + jitter*ox2; vec4 dy2 = Pfy + jitter*oy2; vec4 dz2 = Pf.z - 1.0 + jitter*oz2; vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;// z+0 vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;// z+1 // Sort out the two smallest distances (F1, F2) #if 0 // Cheat and sort out only F1 d1 = min(d1, d2); d1.xy = min(d1.xy, d1.wz); d1.x = min(d1.x, d1.y); return vec2(sqrt(d1.x)); #else // Do it right and sort out both F1 and F2 vec4 d = min(d1, d2);// F1 is now in d d2 = max(d1, d2);// Make sure we keep all candidates for F2 d.xy = (d.x < d.y) ? d.xy : d.yx;// Swap smallest to d.x d.xz = (d.x < d.z) ? d.xz : d.zx; d.xw = (d.x < d.w) ? d.xw : d.wx;// F1 is now in d.x d.yzw = min(d.yzw, d2.yzw);// F2 now not in d2.yzw d.y = min(d.y, d.z);// nor in d.z d.y = min(d.y, d.w);// nor in d.w d.y = min(d.y, d2.x);// F2 is now in d.y return sqrt(d.xy);// F1 and F2 #endif }","title":"cellular2x2x2(vec3 P)"},{"location":"lib/noise/cellular3d.glsl/","text":"cellular3d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl cellular(vec3 P) frex:shaders/lib/noise/cellular3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 3D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. 3x3x3 search region for good F2 everywhere, but a lot slower than the 2x2x2 version. The code below is a bit scary even to its author, but it has at least half decent performance on a modern GPU. In any case, it beats any software implementation of Worley noise hands down. { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 1/2-K/2 #define K2 0.020408163265306// 1/(7*7) #define Kz 0.166666666667// 1/6 #define Kzo 0.416666666667// 1/2-1/6*2 #define jitter 1.0// smaller jitter gives more regular pattern vec3 Pi = mod289(floor(P)); vec3 Pf = fract(P) - 0.5; vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0); vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0); vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0); vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0)); vec3 p1 = permute(p + Pi.y - 1.0); vec3 p2 = permute(p + Pi.y); vec3 p3 = permute(p + Pi.y + 1.0); vec3 p11 = permute(p1 + Pi.z - 1.0); vec3 p12 = permute(p1 + Pi.z); vec3 p13 = permute(p1 + Pi.z + 1.0); vec3 p21 = permute(p2 + Pi.z - 1.0); vec3 p22 = permute(p2 + Pi.z); vec3 p23 = permute(p2 + Pi.z + 1.0); vec3 p31 = permute(p3 + Pi.z - 1.0); vec3 p32 = permute(p3 + Pi.z); vec3 p33 = permute(p3 + Pi.z + 1.0); vec3 ox11 = fract(p11*K) - Ko; vec3 oy11 = mod7(floor(p11*K))*K - Ko; vec3 oz11 = floor(p11*K2)*Kz - Kzo;// p11 < 289 guaranteed vec3 ox12 = fract(p12*K) - Ko; vec3 oy12 = mod7(floor(p12*K))*K - Ko; vec3 oz12 = floor(p12*K2)*Kz - Kzo; vec3 ox13 = fract(p13*K) - Ko; vec3 oy13 = mod7(floor(p13*K))*K - Ko; vec3 oz13 = floor(p13*K2)*Kz - Kzo; vec3 ox21 = fract(p21*K) - Ko; vec3 oy21 = mod7(floor(p21*K))*K - Ko; vec3 oz21 = floor(p21*K2)*Kz - Kzo; vec3 ox22 = fract(p22*K) - Ko; vec3 oy22 = mod7(floor(p22*K))*K - Ko; vec3 oz22 = floor(p22*K2)*Kz - Kzo; vec3 ox23 = fract(p23*K) - Ko; vec3 oy23 = mod7(floor(p23*K))*K - Ko; vec3 oz23 = floor(p23*K2)*Kz - Kzo; vec3 ox31 = fract(p31*K) - Ko; vec3 oy31 = mod7(floor(p31*K))*K - Ko; vec3 oz31 = floor(p31*K2)*Kz - Kzo; vec3 ox32 = fract(p32*K) - Ko; vec3 oy32 = mod7(floor(p32*K))*K - Ko; vec3 oz32 = floor(p32*K2)*Kz - Kzo; vec3 ox33 = fract(p33*K) - Ko; vec3 oy33 = mod7(floor(p33*K))*K - Ko; vec3 oz33 = floor(p33*K2)*Kz - Kzo; vec3 dx11 = Pfx + jitter*ox11; vec3 dy11 = Pfy.x + jitter*oy11; vec3 dz11 = Pfz.x + jitter*oz11; vec3 dx12 = Pfx + jitter*ox12; vec3 dy12 = Pfy.x + jitter*oy12; vec3 dz12 = Pfz.y + jitter*oz12; vec3 dx13 = Pfx + jitter*ox13; vec3 dy13 = Pfy.x + jitter*oy13; vec3 dz13 = Pfz.z + jitter*oz13; vec3 dx21 = Pfx + jitter*ox21; vec3 dy21 = Pfy.y + jitter*oy21; vec3 dz21 = Pfz.x + jitter*oz21; vec3 dx22 = Pfx + jitter*ox22; vec3 dy22 = Pfy.y + jitter*oy22; vec3 dz22 = Pfz.y + jitter*oz22; vec3 dx23 = Pfx + jitter*ox23; vec3 dy23 = Pfy.y + jitter*oy23; vec3 dz23 = Pfz.z + jitter*oz23; vec3 dx31 = Pfx + jitter*ox31; vec3 dy31 = Pfy.z + jitter*oy31; vec3 dz31 = Pfz.x + jitter*oz31; vec3 dx32 = Pfx + jitter*ox32; vec3 dy32 = Pfy.z + jitter*oy32; vec3 dz32 = Pfz.y + jitter*oz32; vec3 dx33 = Pfx + jitter*ox33; vec3 dy33 = Pfy.z + jitter*oy33; vec3 dz33 = Pfz.z + jitter*oz33; vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11; vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12; vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13; vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21; vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22; vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23; vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31; vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32; vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33; // Sort out the two smallest distances (F1, F2) #if 0 // Cheat and sort out only F1 vec3 d1 = min(min(d11, d12), d13); vec3 d2 = min(min(d21, d22), d23); vec3 d3 = min(min(d31, d32), d33); vec3 d = min(min(d1, d2), d3); d.x = min(min(d.x, d.y), d.z); return vec2(sqrt(d.x));// F1 duplicated, no F2 computed #else // Do it right and sort out both F1 and F2 vec3 d1a = min(d11, d12); d12 = max(d11, d12); d11 = min(d1a, d13);// Smallest now not in d12 or d13 d13 = max(d1a, d13); d12 = min(d12, d13);// 2nd smallest now not in d13 vec3 d2a = min(d21, d22); d22 = max(d21, d22); d21 = min(d2a, d23);// Smallest now not in d22 or d23 d23 = max(d2a, d23); d22 = min(d22, d23);// 2nd smallest now not in d23 vec3 d3a = min(d31, d32); d32 = max(d31, d32); d31 = min(d3a, d33);// Smallest now not in d32 or d33 d33 = max(d3a, d33); d32 = min(d32, d33);// 2nd smallest now not in d33 vec3 da = min(d11, d21); d21 = max(d11, d21); d11 = min(da, d31);// Smallest now in d11 d31 = max(da, d31);// 2nd smallest now not in d31 d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx; d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx;// d11.x now smallest d12 = min(d12, d21);// 2nd smallest now not in d21 d12 = min(d12, d22);// nor in d22 d12 = min(d12, d31);// nor in d31 d12 = min(d12, d32);// nor in d32 d11.yz = min(d11.yz, d12.xy);// nor in d12.yz d11.y = min(d11.y, d12.z);// Only two more to go d11.y = min(d11.y, d11.z);// Done! (Phew!) return sqrt(d11.xy);// F1, F2 #endif }","title":"cellular3d.glsl"},{"location":"lib/noise/cellular3d.glsl/#cellular3dglsl","text":"","title":"cellular3d.glsl"},{"location":"lib/noise/cellular3d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/cellular3d.glsl/#cellularvec3-p","text":"frex:shaders/lib/noise/cellular3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Cellular noise (\"Worley noise\") in 3D in GLSL. Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved. This code is released under the conditions of the MIT license. See LICENSE file for details. https://github.com/stegu/webgl-noise Cellular noise, returning F1 and F2 in a vec2. 3x3x3 search region for good F2 everywhere, but a lot slower than the 2x2x2 version. The code below is a bit scary even to its author, but it has at least half decent performance on a modern GPU. In any case, it beats any software implementation of Worley noise hands down. { #define K 0.142857142857// 1/7 #define Ko 0.428571428571// 1/2-K/2 #define K2 0.020408163265306// 1/(7*7) #define Kz 0.166666666667// 1/6 #define Kzo 0.416666666667// 1/2-1/6*2 #define jitter 1.0// smaller jitter gives more regular pattern vec3 Pi = mod289(floor(P)); vec3 Pf = fract(P) - 0.5; vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0); vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0); vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0); vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0)); vec3 p1 = permute(p + Pi.y - 1.0); vec3 p2 = permute(p + Pi.y); vec3 p3 = permute(p + Pi.y + 1.0); vec3 p11 = permute(p1 + Pi.z - 1.0); vec3 p12 = permute(p1 + Pi.z); vec3 p13 = permute(p1 + Pi.z + 1.0); vec3 p21 = permute(p2 + Pi.z - 1.0); vec3 p22 = permute(p2 + Pi.z); vec3 p23 = permute(p2 + Pi.z + 1.0); vec3 p31 = permute(p3 + Pi.z - 1.0); vec3 p32 = permute(p3 + Pi.z); vec3 p33 = permute(p3 + Pi.z + 1.0); vec3 ox11 = fract(p11*K) - Ko; vec3 oy11 = mod7(floor(p11*K))*K - Ko; vec3 oz11 = floor(p11*K2)*Kz - Kzo;// p11 < 289 guaranteed vec3 ox12 = fract(p12*K) - Ko; vec3 oy12 = mod7(floor(p12*K))*K - Ko; vec3 oz12 = floor(p12*K2)*Kz - Kzo; vec3 ox13 = fract(p13*K) - Ko; vec3 oy13 = mod7(floor(p13*K))*K - Ko; vec3 oz13 = floor(p13*K2)*Kz - Kzo; vec3 ox21 = fract(p21*K) - Ko; vec3 oy21 = mod7(floor(p21*K))*K - Ko; vec3 oz21 = floor(p21*K2)*Kz - Kzo; vec3 ox22 = fract(p22*K) - Ko; vec3 oy22 = mod7(floor(p22*K))*K - Ko; vec3 oz22 = floor(p22*K2)*Kz - Kzo; vec3 ox23 = fract(p23*K) - Ko; vec3 oy23 = mod7(floor(p23*K))*K - Ko; vec3 oz23 = floor(p23*K2)*Kz - Kzo; vec3 ox31 = fract(p31*K) - Ko; vec3 oy31 = mod7(floor(p31*K))*K - Ko; vec3 oz31 = floor(p31*K2)*Kz - Kzo; vec3 ox32 = fract(p32*K) - Ko; vec3 oy32 = mod7(floor(p32*K))*K - Ko; vec3 oz32 = floor(p32*K2)*Kz - Kzo; vec3 ox33 = fract(p33*K) - Ko; vec3 oy33 = mod7(floor(p33*K))*K - Ko; vec3 oz33 = floor(p33*K2)*Kz - Kzo; vec3 dx11 = Pfx + jitter*ox11; vec3 dy11 = Pfy.x + jitter*oy11; vec3 dz11 = Pfz.x + jitter*oz11; vec3 dx12 = Pfx + jitter*ox12; vec3 dy12 = Pfy.x + jitter*oy12; vec3 dz12 = Pfz.y + jitter*oz12; vec3 dx13 = Pfx + jitter*ox13; vec3 dy13 = Pfy.x + jitter*oy13; vec3 dz13 = Pfz.z + jitter*oz13; vec3 dx21 = Pfx + jitter*ox21; vec3 dy21 = Pfy.y + jitter*oy21; vec3 dz21 = Pfz.x + jitter*oz21; vec3 dx22 = Pfx + jitter*ox22; vec3 dy22 = Pfy.y + jitter*oy22; vec3 dz22 = Pfz.y + jitter*oz22; vec3 dx23 = Pfx + jitter*ox23; vec3 dy23 = Pfy.y + jitter*oy23; vec3 dz23 = Pfz.z + jitter*oz23; vec3 dx31 = Pfx + jitter*ox31; vec3 dy31 = Pfy.z + jitter*oy31; vec3 dz31 = Pfz.x + jitter*oz31; vec3 dx32 = Pfx + jitter*ox32; vec3 dy32 = Pfy.z + jitter*oy32; vec3 dz32 = Pfz.y + jitter*oz32; vec3 dx33 = Pfx + jitter*ox33; vec3 dy33 = Pfy.z + jitter*oy33; vec3 dz33 = Pfz.z + jitter*oz33; vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11; vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12; vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13; vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21; vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22; vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23; vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31; vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32; vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33; // Sort out the two smallest distances (F1, F2) #if 0 // Cheat and sort out only F1 vec3 d1 = min(min(d11, d12), d13); vec3 d2 = min(min(d21, d22), d23); vec3 d3 = min(min(d31, d32), d33); vec3 d = min(min(d1, d2), d3); d.x = min(min(d.x, d.y), d.z); return vec2(sqrt(d.x));// F1 duplicated, no F2 computed #else // Do it right and sort out both F1 and F2 vec3 d1a = min(d11, d12); d12 = max(d11, d12); d11 = min(d1a, d13);// Smallest now not in d12 or d13 d13 = max(d1a, d13); d12 = min(d12, d13);// 2nd smallest now not in d13 vec3 d2a = min(d21, d22); d22 = max(d21, d22); d21 = min(d2a, d23);// Smallest now not in d22 or d23 d23 = max(d2a, d23); d22 = min(d22, d23);// 2nd smallest now not in d23 vec3 d3a = min(d31, d32); d32 = max(d31, d32); d31 = min(d3a, d33);// Smallest now not in d32 or d33 d33 = max(d3a, d33); d32 = min(d32, d33);// 2nd smallest now not in d33 vec3 da = min(d11, d21); d21 = max(d11, d21); d11 = min(da, d31);// Smallest now in d11 d31 = max(da, d31);// 2nd smallest now not in d31 d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx; d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx;// d11.x now smallest d12 = min(d12, d21);// 2nd smallest now not in d21 d12 = min(d12, d22);// nor in d22 d12 = min(d12, d31);// nor in d31 d12 = min(d12, d32);// nor in d32 d11.yz = min(d11.yz, d12.xy);// nor in d12.yz d11.y = min(d11.y, d12.z);// Only two more to go d11.y = min(d11.y, d11.z);// Done! (Phew!) return sqrt(d11.xy);// F1, F2 #endif }","title":"cellular(vec3 P)"},{"location":"lib/noise/classicnoise2d.glsl/","text":"classicnoise2d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl fade(vec2 t) frex:shaders/lib/noise/classicnoise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 2D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-08-22 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); } cnoise(vec2 P) Classic Perlin noise { vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0); vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0); Pi = mod289(Pi);// To avoid truncation effects in permutation vec4 ix = Pi.xzxz; vec4 iy = Pi.yyww; vec4 fx = Pf.xzxz; vec4 fy = Pf.yyww; vec4 i = permute(permute(ix) + iy); vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0; vec4 gy = abs(gx) - 0.5; vec4 tx = floor(gx + 0.5); gx = gx - tx; vec2 g00 = vec2(gx.x, gy.x); vec2 g10 = vec2(gx.y, gy.y); vec2 g01 = vec2(gx.z, gy.z); vec2 g11 = vec2(gx.w, gy.w); vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11))); g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w; float n00 = dot(g00, vec2(fx.x, fy.x)); float n10 = dot(g10, vec2(fx.y, fy.y)); float n01 = dot(g01, vec2(fx.z, fy.z)); float n11 = dot(g11, vec2(fx.w, fy.w)); vec2 fade_xy = fade(Pf.xy); vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x); float n_xy = mix(n_x.x, n_x.y, fade_xy.y); return 2.3 * n_xy; } pnoise(vec2 P, vec2 rep) Classic Perlin noise, periodic variant { vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0); vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0); Pi = mod(Pi, rep.xyxy);// To create noise with explicit period Pi = mod289(Pi);// To avoid truncation effects in permutation vec4 ix = Pi.xzxz; vec4 iy = Pi.yyww; vec4 fx = Pf.xzxz; vec4 fy = Pf.yyww; vec4 i = permute(permute(ix) + iy); vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0; vec4 gy = abs(gx) - 0.5; vec4 tx = floor(gx + 0.5); gx = gx - tx; vec2 g00 = vec2(gx.x, gy.x); vec2 g10 = vec2(gx.y, gy.y); vec2 g01 = vec2(gx.z, gy.z); vec2 g11 = vec2(gx.w, gy.w); vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11))); g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w; float n00 = dot(g00, vec2(fx.x, fy.x)); float n10 = dot(g10, vec2(fx.y, fy.y)); float n01 = dot(g01, vec2(fx.z, fy.z)); float n11 = dot(g11, vec2(fx.w, fy.w)); vec2 fade_xy = fade(Pf.xy); vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x); float n_xy = mix(n_x.x, n_x.y, fade_xy.y); return 2.3 * n_xy; }","title":"classicnoise2d.glsl"},{"location":"lib/noise/classicnoise2d.glsl/#classicnoise2dglsl","text":"","title":"classicnoise2d.glsl"},{"location":"lib/noise/classicnoise2d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/classicnoise2d.glsl/#fadevec2-t","text":"frex:shaders/lib/noise/classicnoise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 2D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-08-22 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); }","title":"fade(vec2 t)"},{"location":"lib/noise/classicnoise2d.glsl/#cnoisevec2-p","text":"Classic Perlin noise { vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0); vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0); Pi = mod289(Pi);// To avoid truncation effects in permutation vec4 ix = Pi.xzxz; vec4 iy = Pi.yyww; vec4 fx = Pf.xzxz; vec4 fy = Pf.yyww; vec4 i = permute(permute(ix) + iy); vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0; vec4 gy = abs(gx) - 0.5; vec4 tx = floor(gx + 0.5); gx = gx - tx; vec2 g00 = vec2(gx.x, gy.x); vec2 g10 = vec2(gx.y, gy.y); vec2 g01 = vec2(gx.z, gy.z); vec2 g11 = vec2(gx.w, gy.w); vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11))); g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w; float n00 = dot(g00, vec2(fx.x, fy.x)); float n10 = dot(g10, vec2(fx.y, fy.y)); float n01 = dot(g01, vec2(fx.z, fy.z)); float n11 = dot(g11, vec2(fx.w, fy.w)); vec2 fade_xy = fade(Pf.xy); vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x); float n_xy = mix(n_x.x, n_x.y, fade_xy.y); return 2.3 * n_xy; }","title":"cnoise(vec2 P)"},{"location":"lib/noise/classicnoise2d.glsl/#pnoisevec2-p-vec2-rep","text":"Classic Perlin noise, periodic variant { vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0); vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0); Pi = mod(Pi, rep.xyxy);// To create noise with explicit period Pi = mod289(Pi);// To avoid truncation effects in permutation vec4 ix = Pi.xzxz; vec4 iy = Pi.yyww; vec4 fx = Pf.xzxz; vec4 fy = Pf.yyww; vec4 i = permute(permute(ix) + iy); vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0; vec4 gy = abs(gx) - 0.5; vec4 tx = floor(gx + 0.5); gx = gx - tx; vec2 g00 = vec2(gx.x, gy.x); vec2 g10 = vec2(gx.y, gy.y); vec2 g01 = vec2(gx.z, gy.z); vec2 g11 = vec2(gx.w, gy.w); vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11))); g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w; float n00 = dot(g00, vec2(fx.x, fy.x)); float n10 = dot(g10, vec2(fx.y, fy.y)); float n01 = dot(g01, vec2(fx.z, fy.z)); float n11 = dot(g11, vec2(fx.w, fy.w)); vec2 fade_xy = fade(Pf.xy); vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x); float n_xy = mix(n_x.x, n_x.y, fade_xy.y); return 2.3 * n_xy; }","title":"pnoise(vec2 P, vec2 rep)"},{"location":"lib/noise/classicnoise3d.glsl/","text":"classicnoise3d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl fade(vec3 t) frex:shaders/lib/noise/classicnoise3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 3D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-10-11 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); } cnoise(vec3 P) Classic Perlin noise { vec3 Pi0 = floor(P);// Integer part for indexing vec3 Pi1 = Pi0 + vec3(1.0);// Integer part + 1 Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec3 Pf0 = fract(P);// Fractional part for interpolation vec3 Pf1 = Pf0 - vec3(1.0);// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz; vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 gx0 = ixy0 * (1.0 / 7.0); vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5; gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0)); gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5); vec4 gx1 = ixy1 * (1.0 / 7.0); vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5; gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0)); gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5); vec3 g000 = vec3(gx0.x, gy0.x, gz0.x); vec3 g100 = vec3(gx0.y, gy0.y, gz0.y); vec3 g010 = vec3(gx0.z, gy0.z, gz0.z); vec3 g110 = vec3(gx0.w, gy0.w, gz0.w); vec3 g001 = vec3(gx1.x, gy1.x, gz1.x); vec3 g101 = vec3(gx1.y, gy1.y, gz1.y); vec3 g011 = vec3(gx1.z, gy1.z, gz1.z); vec3 g111 = vec3(gx1.w, gy1.w, gz1.w); vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))); g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w; vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))); g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w; float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz)); float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z)); float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)); float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1); vec3 fade_xyz = fade(Pf0); vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z); vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y); float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); return 2.2 * n_xyz; } pnoise(vec3 P, vec3 rep) Classic Perlin noise, periodic variant { vec3 Pi0 = mod(floor(P), rep);// Integer part, modulo period vec3 Pi1 = mod(Pi0 + vec3(1.0), rep);// Integer part + 1, mod period Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec3 Pf0 = fract(P);// Fractional part for interpolation vec3 Pf1 = Pf0 - vec3(1.0);// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz; vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 gx0 = ixy0 * (1.0 / 7.0); vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5; gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0)); gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5); vec4 gx1 = ixy1 * (1.0 / 7.0); vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5; gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0)); gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5); vec3 g000 = vec3(gx0.x, gy0.x, gz0.x); vec3 g100 = vec3(gx0.y, gy0.y, gz0.y); vec3 g010 = vec3(gx0.z, gy0.z, gz0.z); vec3 g110 = vec3(gx0.w, gy0.w, gz0.w); vec3 g001 = vec3(gx1.x, gy1.x, gz1.x); vec3 g101 = vec3(gx1.y, gy1.y, gz1.y); vec3 g011 = vec3(gx1.z, gy1.z, gz1.z); vec3 g111 = vec3(gx1.w, gy1.w, gz1.w); vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))); g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w; vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))); g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w; float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz)); float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z)); float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)); float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1); vec3 fade_xyz = fade(Pf0); vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z); vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y); float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); return 2.2 * n_xyz; }","title":"classicnoise3d.glsl"},{"location":"lib/noise/classicnoise3d.glsl/#classicnoise3dglsl","text":"","title":"classicnoise3d.glsl"},{"location":"lib/noise/classicnoise3d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/classicnoise3d.glsl/#fadevec3-t","text":"frex:shaders/lib/noise/classicnoise3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 3D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-10-11 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); }","title":"fade(vec3 t)"},{"location":"lib/noise/classicnoise3d.glsl/#cnoisevec3-p","text":"Classic Perlin noise { vec3 Pi0 = floor(P);// Integer part for indexing vec3 Pi1 = Pi0 + vec3(1.0);// Integer part + 1 Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec3 Pf0 = fract(P);// Fractional part for interpolation vec3 Pf1 = Pf0 - vec3(1.0);// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz; vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 gx0 = ixy0 * (1.0 / 7.0); vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5; gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0)); gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5); vec4 gx1 = ixy1 * (1.0 / 7.0); vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5; gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0)); gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5); vec3 g000 = vec3(gx0.x, gy0.x, gz0.x); vec3 g100 = vec3(gx0.y, gy0.y, gz0.y); vec3 g010 = vec3(gx0.z, gy0.z, gz0.z); vec3 g110 = vec3(gx0.w, gy0.w, gz0.w); vec3 g001 = vec3(gx1.x, gy1.x, gz1.x); vec3 g101 = vec3(gx1.y, gy1.y, gz1.y); vec3 g011 = vec3(gx1.z, gy1.z, gz1.z); vec3 g111 = vec3(gx1.w, gy1.w, gz1.w); vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))); g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w; vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))); g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w; float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz)); float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z)); float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)); float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1); vec3 fade_xyz = fade(Pf0); vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z); vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y); float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); return 2.2 * n_xyz; }","title":"cnoise(vec3 P)"},{"location":"lib/noise/classicnoise3d.glsl/#pnoisevec3-p-vec3-rep","text":"Classic Perlin noise, periodic variant { vec3 Pi0 = mod(floor(P), rep);// Integer part, modulo period vec3 Pi1 = mod(Pi0 + vec3(1.0), rep);// Integer part + 1, mod period Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec3 Pf0 = fract(P);// Fractional part for interpolation vec3 Pf1 = Pf0 - vec3(1.0);// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz; vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 gx0 = ixy0 * (1.0 / 7.0); vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5; gx0 = fract(gx0); vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0)); gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5); vec4 gx1 = ixy1 * (1.0 / 7.0); vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5; gx1 = fract(gx1); vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0)); gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5); vec3 g000 = vec3(gx0.x, gy0.x, gz0.x); vec3 g100 = vec3(gx0.y, gy0.y, gz0.y); vec3 g010 = vec3(gx0.z, gy0.z, gz0.z); vec3 g110 = vec3(gx0.w, gy0.w, gz0.w); vec3 g001 = vec3(gx1.x, gy1.x, gz1.x); vec3 g101 = vec3(gx1.y, gy1.y, gz1.y); vec3 g011 = vec3(gx1.z, gy1.z, gz1.z); vec3 g111 = vec3(gx1.w, gy1.w, gz1.w); vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110))); g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w; vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111))); g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w; float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz)); float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z)); float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z)); float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1); vec3 fade_xyz = fade(Pf0); vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z); vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y); float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); return 2.2 * n_xyz; }","title":"pnoise(vec3 P, vec3 rep)"},{"location":"lib/noise/classicnoise4d.glsl/","text":"classicnoise4d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl fade(vec4 t) frex:shaders/lib/noise/classicnoise4d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 4D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-08-22 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); } cnoise(vec4 P) Classic Perlin noise { vec4 Pi0 = floor(P);// Integer part for indexing vec4 Pi1 = Pi0 + 1.0;// Integer part + 1 Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec4 Pf0 = fract(P);// Fractional part for interpolation vec4 Pf1 = Pf0 - 1.0;// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = vec4(Pi0.zzzz); vec4 iz1 = vec4(Pi1.zzzz); vec4 iw0 = vec4(Pi0.wwww); vec4 iw1 = vec4(Pi1.wwww); vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 ixy00 = permute(ixy0 + iw0); vec4 ixy01 = permute(ixy0 + iw1); vec4 ixy10 = permute(ixy1 + iw0); vec4 ixy11 = permute(ixy1 + iw1); vec4 gx00 = ixy00 * (1.0 / 7.0); vec4 gy00 = floor(gx00) * (1.0 / 7.0); vec4 gz00 = floor(gy00) * (1.0 / 6.0); gx00 = fract(gx00) - 0.5; gy00 = fract(gy00) - 0.5; gz00 = fract(gz00) - 0.5; vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00); vec4 sw00 = step(gw00, vec4(0.0)); gx00 -= sw00 * (step(0.0, gx00) - 0.5); gy00 -= sw00 * (step(0.0, gy00) - 0.5); vec4 gx01 = ixy01 * (1.0 / 7.0); vec4 gy01 = floor(gx01) * (1.0 / 7.0); vec4 gz01 = floor(gy01) * (1.0 / 6.0); gx01 = fract(gx01) - 0.5; gy01 = fract(gy01) - 0.5; gz01 = fract(gz01) - 0.5; vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01); vec4 sw01 = step(gw01, vec4(0.0)); gx01 -= sw01 * (step(0.0, gx01) - 0.5); gy01 -= sw01 * (step(0.0, gy01) - 0.5); vec4 gx10 = ixy10 * (1.0 / 7.0); vec4 gy10 = floor(gx10) * (1.0 / 7.0); vec4 gz10 = floor(gy10) * (1.0 / 6.0); gx10 = fract(gx10) - 0.5; gy10 = fract(gy10) - 0.5; gz10 = fract(gz10) - 0.5; vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10); vec4 sw10 = step(gw10, vec4(0.0)); gx10 -= sw10 * (step(0.0, gx10) - 0.5); gy10 -= sw10 * (step(0.0, gy10) - 0.5); vec4 gx11 = ixy11 * (1.0 / 7.0); vec4 gy11 = floor(gx11) * (1.0 / 7.0); vec4 gz11 = floor(gy11) * (1.0 / 6.0); gx11 = fract(gx11) - 0.5; gy11 = fract(gy11) - 0.5; gz11 = fract(gz11) - 0.5; vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11); vec4 sw11 = step(gw11, vec4(0.0)); gx11 -= sw11 * (step(0.0, gx11) - 0.5); gy11 -= sw11 * (step(0.0, gy11) - 0.5); vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x); vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y); vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z); vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w); vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x); vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y); vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z); vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w); vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x); vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y); vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z); vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w); vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x); vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y); vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z); vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w); vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100))); g0000 *= norm00.x; g0100 *= norm00.y; g1000 *= norm00.z; g1100 *= norm00.w; vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101))); g0001 *= norm01.x; g0101 *= norm01.y; g1001 *= norm01.z; g1101 *= norm01.w; vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110))); g0010 *= norm10.x; g0110 *= norm10.y; g1010 *= norm10.z; g1110 *= norm10.w; vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111))); g0011 *= norm11.x; g0111 *= norm11.y; g1011 *= norm11.z; g1111 *= norm11.w; float n0000 = dot(g0000, Pf0); float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw)); float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw)); float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw)); float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w)); float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w)); float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w)); float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w)); float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w)); float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w)); float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w)); float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w)); float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw)); float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw)); float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw)); float n1111 = dot(g1111, Pf1); vec4 fade_xyzw = fade(Pf0); vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w); vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w); vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z); vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y); float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x); return 2.2 * n_xyzw; } pnoise(vec4 P, vec4 rep) Classic Perlin noise, periodic version { vec4 Pi0 = mod(floor(P), rep);// Integer part modulo rep vec4 Pi1 = mod(Pi0 + 1.0, rep);// Integer part + 1 mod rep Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec4 Pf0 = fract(P);// Fractional part for interpolation vec4 Pf1 = Pf0 - 1.0;// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = vec4(Pi0.zzzz); vec4 iz1 = vec4(Pi1.zzzz); vec4 iw0 = vec4(Pi0.wwww); vec4 iw1 = vec4(Pi1.wwww); vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 ixy00 = permute(ixy0 + iw0); vec4 ixy01 = permute(ixy0 + iw1); vec4 ixy10 = permute(ixy1 + iw0); vec4 ixy11 = permute(ixy1 + iw1); vec4 gx00 = ixy00 * (1.0 / 7.0); vec4 gy00 = floor(gx00) * (1.0 / 7.0); vec4 gz00 = floor(gy00) * (1.0 / 6.0); gx00 = fract(gx00) - 0.5; gy00 = fract(gy00) - 0.5; gz00 = fract(gz00) - 0.5; vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00); vec4 sw00 = step(gw00, vec4(0.0)); gx00 -= sw00 * (step(0.0, gx00) - 0.5); gy00 -= sw00 * (step(0.0, gy00) - 0.5); vec4 gx01 = ixy01 * (1.0 / 7.0); vec4 gy01 = floor(gx01) * (1.0 / 7.0); vec4 gz01 = floor(gy01) * (1.0 / 6.0); gx01 = fract(gx01) - 0.5; gy01 = fract(gy01) - 0.5; gz01 = fract(gz01) - 0.5; vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01); vec4 sw01 = step(gw01, vec4(0.0)); gx01 -= sw01 * (step(0.0, gx01) - 0.5); gy01 -= sw01 * (step(0.0, gy01) - 0.5); vec4 gx10 = ixy10 * (1.0 / 7.0); vec4 gy10 = floor(gx10) * (1.0 / 7.0); vec4 gz10 = floor(gy10) * (1.0 / 6.0); gx10 = fract(gx10) - 0.5; gy10 = fract(gy10) - 0.5; gz10 = fract(gz10) - 0.5; vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10); vec4 sw10 = step(gw10, vec4(0.0)); gx10 -= sw10 * (step(0.0, gx10) - 0.5); gy10 -= sw10 * (step(0.0, gy10) - 0.5); vec4 gx11 = ixy11 * (1.0 / 7.0); vec4 gy11 = floor(gx11) * (1.0 / 7.0); vec4 gz11 = floor(gy11) * (1.0 / 6.0); gx11 = fract(gx11) - 0.5; gy11 = fract(gy11) - 0.5; gz11 = fract(gz11) - 0.5; vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11); vec4 sw11 = step(gw11, vec4(0.0)); gx11 -= sw11 * (step(0.0, gx11) - 0.5); gy11 -= sw11 * (step(0.0, gy11) - 0.5); vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x); vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y); vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z); vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w); vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x); vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y); vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z); vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w); vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x); vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y); vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z); vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w); vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x); vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y); vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z); vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w); vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100))); g0000 *= norm00.x; g0100 *= norm00.y; g1000 *= norm00.z; g1100 *= norm00.w; vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101))); g0001 *= norm01.x; g0101 *= norm01.y; g1001 *= norm01.z; g1101 *= norm01.w; vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110))); g0010 *= norm10.x; g0110 *= norm10.y; g1010 *= norm10.z; g1110 *= norm10.w; vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111))); g0011 *= norm11.x; g0111 *= norm11.y; g1011 *= norm11.z; g1111 *= norm11.w; float n0000 = dot(g0000, Pf0); float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw)); float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw)); float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw)); float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w)); float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w)); float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w)); float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w)); float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w)); float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w)); float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w)); float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w)); float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw)); float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw)); float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw)); float n1111 = dot(g1111, Pf1); vec4 fade_xyzw = fade(Pf0); vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w); vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w); vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z); vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y); float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x); return 2.2 * n_xyzw; }","title":"classicnoise4d.glsl"},{"location":"lib/noise/classicnoise4d.glsl/#classicnoise4dglsl","text":"","title":"classicnoise4d.glsl"},{"location":"lib/noise/classicnoise4d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/classicnoise4d.glsl/#fadevec4-t","text":"frex:shaders/lib/noise/classicnoise4d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. GLSL textureless classic 4D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-08-22 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise { return t*t*t*(t*(t*6.0-15.0)+10.0); }","title":"fade(vec4 t)"},{"location":"lib/noise/classicnoise4d.glsl/#cnoisevec4-p","text":"Classic Perlin noise { vec4 Pi0 = floor(P);// Integer part for indexing vec4 Pi1 = Pi0 + 1.0;// Integer part + 1 Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec4 Pf0 = fract(P);// Fractional part for interpolation vec4 Pf1 = Pf0 - 1.0;// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = vec4(Pi0.zzzz); vec4 iz1 = vec4(Pi1.zzzz); vec4 iw0 = vec4(Pi0.wwww); vec4 iw1 = vec4(Pi1.wwww); vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 ixy00 = permute(ixy0 + iw0); vec4 ixy01 = permute(ixy0 + iw1); vec4 ixy10 = permute(ixy1 + iw0); vec4 ixy11 = permute(ixy1 + iw1); vec4 gx00 = ixy00 * (1.0 / 7.0); vec4 gy00 = floor(gx00) * (1.0 / 7.0); vec4 gz00 = floor(gy00) * (1.0 / 6.0); gx00 = fract(gx00) - 0.5; gy00 = fract(gy00) - 0.5; gz00 = fract(gz00) - 0.5; vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00); vec4 sw00 = step(gw00, vec4(0.0)); gx00 -= sw00 * (step(0.0, gx00) - 0.5); gy00 -= sw00 * (step(0.0, gy00) - 0.5); vec4 gx01 = ixy01 * (1.0 / 7.0); vec4 gy01 = floor(gx01) * (1.0 / 7.0); vec4 gz01 = floor(gy01) * (1.0 / 6.0); gx01 = fract(gx01) - 0.5; gy01 = fract(gy01) - 0.5; gz01 = fract(gz01) - 0.5; vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01); vec4 sw01 = step(gw01, vec4(0.0)); gx01 -= sw01 * (step(0.0, gx01) - 0.5); gy01 -= sw01 * (step(0.0, gy01) - 0.5); vec4 gx10 = ixy10 * (1.0 / 7.0); vec4 gy10 = floor(gx10) * (1.0 / 7.0); vec4 gz10 = floor(gy10) * (1.0 / 6.0); gx10 = fract(gx10) - 0.5; gy10 = fract(gy10) - 0.5; gz10 = fract(gz10) - 0.5; vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10); vec4 sw10 = step(gw10, vec4(0.0)); gx10 -= sw10 * (step(0.0, gx10) - 0.5); gy10 -= sw10 * (step(0.0, gy10) - 0.5); vec4 gx11 = ixy11 * (1.0 / 7.0); vec4 gy11 = floor(gx11) * (1.0 / 7.0); vec4 gz11 = floor(gy11) * (1.0 / 6.0); gx11 = fract(gx11) - 0.5; gy11 = fract(gy11) - 0.5; gz11 = fract(gz11) - 0.5; vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11); vec4 sw11 = step(gw11, vec4(0.0)); gx11 -= sw11 * (step(0.0, gx11) - 0.5); gy11 -= sw11 * (step(0.0, gy11) - 0.5); vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x); vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y); vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z); vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w); vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x); vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y); vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z); vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w); vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x); vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y); vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z); vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w); vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x); vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y); vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z); vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w); vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100))); g0000 *= norm00.x; g0100 *= norm00.y; g1000 *= norm00.z; g1100 *= norm00.w; vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101))); g0001 *= norm01.x; g0101 *= norm01.y; g1001 *= norm01.z; g1101 *= norm01.w; vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110))); g0010 *= norm10.x; g0110 *= norm10.y; g1010 *= norm10.z; g1110 *= norm10.w; vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111))); g0011 *= norm11.x; g0111 *= norm11.y; g1011 *= norm11.z; g1111 *= norm11.w; float n0000 = dot(g0000, Pf0); float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw)); float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw)); float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw)); float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w)); float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w)); float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w)); float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w)); float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w)); float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w)); float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w)); float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w)); float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw)); float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw)); float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw)); float n1111 = dot(g1111, Pf1); vec4 fade_xyzw = fade(Pf0); vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w); vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w); vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z); vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y); float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x); return 2.2 * n_xyzw; }","title":"cnoise(vec4 P)"},{"location":"lib/noise/classicnoise4d.glsl/#pnoisevec4-p-vec4-rep","text":"Classic Perlin noise, periodic version { vec4 Pi0 = mod(floor(P), rep);// Integer part modulo rep vec4 Pi1 = mod(Pi0 + 1.0, rep);// Integer part + 1 mod rep Pi0 = mod289(Pi0); Pi1 = mod289(Pi1); vec4 Pf0 = fract(P);// Fractional part for interpolation vec4 Pf1 = Pf0 - 1.0;// Fractional part - 1.0 vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy); vec4 iz0 = vec4(Pi0.zzzz); vec4 iz1 = vec4(Pi1.zzzz); vec4 iw0 = vec4(Pi0.wwww); vec4 iw1 = vec4(Pi1.wwww); vec4 ixy = permute(permute(ix) + iy); vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1); vec4 ixy00 = permute(ixy0 + iw0); vec4 ixy01 = permute(ixy0 + iw1); vec4 ixy10 = permute(ixy1 + iw0); vec4 ixy11 = permute(ixy1 + iw1); vec4 gx00 = ixy00 * (1.0 / 7.0); vec4 gy00 = floor(gx00) * (1.0 / 7.0); vec4 gz00 = floor(gy00) * (1.0 / 6.0); gx00 = fract(gx00) - 0.5; gy00 = fract(gy00) - 0.5; gz00 = fract(gz00) - 0.5; vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00); vec4 sw00 = step(gw00, vec4(0.0)); gx00 -= sw00 * (step(0.0, gx00) - 0.5); gy00 -= sw00 * (step(0.0, gy00) - 0.5); vec4 gx01 = ixy01 * (1.0 / 7.0); vec4 gy01 = floor(gx01) * (1.0 / 7.0); vec4 gz01 = floor(gy01) * (1.0 / 6.0); gx01 = fract(gx01) - 0.5; gy01 = fract(gy01) - 0.5; gz01 = fract(gz01) - 0.5; vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01); vec4 sw01 = step(gw01, vec4(0.0)); gx01 -= sw01 * (step(0.0, gx01) - 0.5); gy01 -= sw01 * (step(0.0, gy01) - 0.5); vec4 gx10 = ixy10 * (1.0 / 7.0); vec4 gy10 = floor(gx10) * (1.0 / 7.0); vec4 gz10 = floor(gy10) * (1.0 / 6.0); gx10 = fract(gx10) - 0.5; gy10 = fract(gy10) - 0.5; gz10 = fract(gz10) - 0.5; vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10); vec4 sw10 = step(gw10, vec4(0.0)); gx10 -= sw10 * (step(0.0, gx10) - 0.5); gy10 -= sw10 * (step(0.0, gy10) - 0.5); vec4 gx11 = ixy11 * (1.0 / 7.0); vec4 gy11 = floor(gx11) * (1.0 / 7.0); vec4 gz11 = floor(gy11) * (1.0 / 6.0); gx11 = fract(gx11) - 0.5; gy11 = fract(gy11) - 0.5; gz11 = fract(gz11) - 0.5; vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11); vec4 sw11 = step(gw11, vec4(0.0)); gx11 -= sw11 * (step(0.0, gx11) - 0.5); gy11 -= sw11 * (step(0.0, gy11) - 0.5); vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x); vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y); vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z); vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w); vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x); vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y); vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z); vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w); vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x); vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y); vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z); vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w); vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x); vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y); vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z); vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w); vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100))); g0000 *= norm00.x; g0100 *= norm00.y; g1000 *= norm00.z; g1100 *= norm00.w; vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101))); g0001 *= norm01.x; g0101 *= norm01.y; g1001 *= norm01.z; g1101 *= norm01.w; vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110))); g0010 *= norm10.x; g0110 *= norm10.y; g1010 *= norm10.z; g1110 *= norm10.w; vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111))); g0011 *= norm11.x; g0111 *= norm11.y; g1011 *= norm11.z; g1111 *= norm11.w; float n0000 = dot(g0000, Pf0); float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw)); float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw)); float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw)); float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w)); float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w)); float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w)); float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w)); float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w)); float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w)); float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w)); float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w)); float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw)); float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw)); float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw)); float n1111 = dot(g1111, Pf1); vec4 fade_xyzw = fade(Pf0); vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w); vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w); vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z); vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y); float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x); return 2.2 * n_xyzw; }","title":"pnoise(vec4 P, vec4 rep)"},{"location":"lib/noise/noise2d.glsl/","text":"noise2d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl snoise(vec2 v) frex:shaders/lib/noise/noise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0 0.366025403784439, // 0.5*(sqrt(3.0)-1.0) -0.577350269189626, // -1.0 + 2.0 * C.x 0.024390243902439);// 1.0 / 41.0 // First corner vec2 i = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx); // Other corners vec2 i1; //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0 //i1.y = 1.0 - i1.x; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // x0 = x0 - 0.0 + 0.0 * C.xx ; // x1 = x0 - i1 + 1.0 * C.xx ; // x2 = x0 - 1.0 + 2.0 * C.xx ; vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; // Permutations i = mod289(i);// Avoid truncation effects in permutation vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0)); vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0); m = m*m; m = m*m; // Gradients: 41 points uniformly over a line, mapped onto a diamond. // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287) vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; // Normalise gradients implicitly by scaling m // Approximation of: m *= inversesqrt( a0*a0 + h*h ); m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h); // Compute final noise value at P vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }","title":"noise2d.glsl"},{"location":"lib/noise/noise2d.glsl/#noise2dglsl","text":"","title":"noise2d.glsl"},{"location":"lib/noise/noise2d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/noise2d.glsl/#snoisevec2-v","text":"frex:shaders/lib/noise/noise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0 0.366025403784439, // 0.5*(sqrt(3.0)-1.0) -0.577350269189626, // -1.0 + 2.0 * C.x 0.024390243902439);// 1.0 / 41.0 // First corner vec2 i = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx); // Other corners vec2 i1; //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0 //i1.y = 1.0 - i1.x; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // x0 = x0 - 0.0 + 0.0 * C.xx ; // x1 = x0 - i1 + 1.0 * C.xx ; // x2 = x0 - 1.0 + 2.0 * C.xx ; vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; // Permutations i = mod289(i);// Avoid truncation effects in permutation vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0)); vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0); m = m*m; m = m*m; // Gradients: 41 points uniformly over a line, mapped onto a diamond. // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287) vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; // Normalise gradients implicitly by scaling m // Approximation of: m *= inversesqrt( a0*a0 + h*h ); m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h); // Compute final noise value at P vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }","title":"snoise(vec2 v)"},{"location":"lib/noise/noise3d.glsl/","text":"noise3d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl snoise(vec3 v) frex:shaders/lib/noise/noise3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); // First corner vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); // Other corners vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); // x0 = x0 - 0.0 + 0.0 * C.xxx; // x1 = x0 - i1 + 1.0 * C.xxx; // x2 = x0 - i2 + 2.0 * C.xxx; // x3 = x0 - 1.0 + 3.0 * C.xxx; vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy;// 2.0*C.x = 1/3 = C.y vec3 x3 = x0 - D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y // Permutations i = mod289(i); vec4 p = permute(permute(permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); // Gradients: 7x7 points over a square, mapped onto an octahedron. // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294) float n_ = 0.142857142857;// 1.0/7.0 vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);// mod(p,7*7) vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);// mod(j,N) vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0; //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0; vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); //Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; // Mix final noise value vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }","title":"noise3d.glsl"},{"location":"lib/noise/noise3d.glsl/#noise3dglsl","text":"","title":"noise3d.glsl"},{"location":"lib/noise/noise3d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/noise3d.glsl/#snoisevec3-v","text":"frex:shaders/lib/noise/noise3d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); // First corner vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); // Other corners vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); // x0 = x0 - 0.0 + 0.0 * C.xxx; // x1 = x0 - i1 + 1.0 * C.xxx; // x2 = x0 - i2 + 2.0 * C.xxx; // x3 = x0 - 1.0 + 3.0 * C.xxx; vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy;// 2.0*C.x = 1/3 = C.y vec3 x3 = x0 - D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y // Permutations i = mod289(i); vec4 p = permute(permute(permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); // Gradients: 7x7 points over a square, mapped onto an octahedron. // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294) float n_ = 0.142857142857;// 1.0/7.0 vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);// mod(p,7*7) vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);// mod(j,N) vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0; //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0; vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); //Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; // Mix final noise value vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }","title":"snoise(vec3 v)"},{"location":"lib/noise/noise3dgrad.glsl/","text":"noise3dgrad.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl snoise(vec3 v, out vec3 gradient) frex:shaders/lib/noise/noise3dgrad.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); // First corner vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); // Other corners vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); // x0 = x0 - 0.0 + 0.0 * C.xxx; // x1 = x0 - i1 + 1.0 * C.xxx; // x2 = x0 - i2 + 2.0 * C.xxx; // x3 = x0 - 1.0 + 3.0 * C.xxx; vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy;// 2.0*C.x = 1/3 = C.y vec3 x3 = x0 - D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y // Permutations i = mod289(i); vec4 p = permute(permute(permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); // Gradients: 7x7 points over a square, mapped onto an octahedron. // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294) float n_ = 0.142857142857;// 1.0/7.0 vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);// mod(p,7*7) vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);// mod(j,N) vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0; //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0; vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); //Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; // Mix final noise value vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); vec4 m2 = m * m; vec4 m4 = m2 * m2; vec4 pdotx = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); // Determine noise gradient vec4 temp = m2 * m * pdotx; gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3); gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3; gradient *= 42.0; return 42.0 * dot(m4, pdotx); }","title":"noise3dgrad.glsl"},{"location":"lib/noise/noise3dgrad.glsl/#noise3dgradglsl","text":"","title":"noise3dgrad.glsl"},{"location":"lib/noise/noise3dgrad.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/noise3dgrad.glsl/#snoisevec3-v-out-vec3-gradient","text":"frex:shaders/lib/noise/noise3dgrad.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); // First corner vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); // Other corners vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); // x0 = x0 - 0.0 + 0.0 * C.xxx; // x1 = x0 - i1 + 1.0 * C.xxx; // x2 = x0 - i2 + 2.0 * C.xxx; // x3 = x0 - 1.0 + 3.0 * C.xxx; vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy;// 2.0*C.x = 1/3 = C.y vec3 x3 = x0 - D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y // Permutations i = mod289(i); vec4 p = permute(permute(permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); // Gradients: 7x7 points over a square, mapped onto an octahedron. // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294) float n_ = 0.142857142857;// 1.0/7.0 vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);// mod(p,7*7) vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_);// mod(j,N) vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0; //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0; vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); //Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; // Mix final noise value vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); vec4 m2 = m * m; vec4 m4 = m2 * m2; vec4 pdotx = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); // Determine noise gradient vec4 temp = m2 * m * pdotx; gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3); gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3; gradient *= 42.0; return 42.0 * dot(m4, pdotx); }","title":"snoise(vec3 v, out vec3 gradient)"},{"location":"lib/noise/noise4d.glsl/","text":"noise4d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl grad4(float j, vec4 ip) frex:shaders/lib/noise/noise4d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0); vec4 p, s; p.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0; p.w = 1.5 - dot(abs(p.xyz), ones.xyz); s = vec4(lessThan(p, vec4(0.0))); p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; return p; } Preprocessor: #define F4 0.309016994374947451 snoise(vec4 v) { const vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4 0.276393202250021, // 2 * G4 0.414589803375032, // 3 * G4 -0.447213595499958);// -1 + 4 * G4 // First corner vec4 i = floor(v + dot(v, vec4(F4))); vec4 x0 = v - i + dot(i, C.xxxx); // Other corners // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI) vec4 i0; vec3 isX = step(x0.yzw, x0.xxx); vec3 isYZ = step(x0.zww, x0.yyz); // i0.x = dot( isX, vec3( 1.0 ) ); i0.x = isX.x + isX.y + isX.z; i0.yzw = 1.0 - isX; // i0.y += dot( isYZ.xy, vec2( 1.0 ) ); i0.y += isYZ.x + isYZ.y; i0.zw += 1.0 - isYZ.xy; i0.z += isYZ.z; i0.w += 1.0 - isYZ.z; // i0 now contains the unique values 0,1,2,3 in each channel vec4 i3 = clamp(i0, 0.0, 1.0); vec4 i2 = clamp(i0-1.0, 0.0, 1.0); vec4 i1 = clamp(i0-2.0, 0.0, 1.0); // x0 = x0 - 0.0 + 0.0 * C.xxxx // x1 = x0 - i1 + 1.0 * C.xxxx // x2 = x0 - i2 + 2.0 * C.xxxx // x3 = x0 - i3 + 3.0 * C.xxxx // x4 = x0 - 1.0 + 4.0 * C.xxxx vec4 x1 = x0 - i1 + C.xxxx; vec4 x2 = x0 - i2 + C.yyyy; vec4 x3 = x0 - i3 + C.zzzz; vec4 x4 = x0 + C.wwww; // Permutations i = mod289(i); float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x); vec4 j1 = permute(permute(permute(permute ( i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0)); // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope // 7*7*6 = 294, which is close to the ring size 17*17 = 289. vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0); vec4 p0 = grad4(j0, ip); vec4 p1 = grad4(j1.x, ip); vec4 p2 = grad4(j1.y, ip); vec4 p3 = grad4(j1.z, ip); vec4 p4 = grad4(j1.w, ip); // Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; p4 *= taylorInvSqrt(dot(p4, p4)); // Mix contributions from the five corners vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0); vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0); m0 = m0 * m0; m1 = m1 * m1; return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))); }","title":"noise4d.glsl"},{"location":"lib/noise/noise4d.glsl/#noise4dglsl","text":"","title":"noise4d.glsl"},{"location":"lib/noise/noise4d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/noise4d.glsl/#grad4float-j-vec4-ip","text":"frex:shaders/lib/noise/noise4d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. Description : Array and textureless GLSL 2D/3D/4D simplex noise functions. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise { const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0); vec4 p, s; p.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0; p.w = 1.5 - dot(abs(p.xyz), ones.xyz); s = vec4(lessThan(p, vec4(0.0))); p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; return p; }","title":"grad4(float j, vec4 ip)"},{"location":"lib/noise/noise4d.glsl/#preprocessor-define-f4-0309016994374947451","text":"","title":"Preprocessor: #define F4 0.309016994374947451"},{"location":"lib/noise/noise4d.glsl/#snoisevec4-v","text":"{ const vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4 0.276393202250021, // 2 * G4 0.414589803375032, // 3 * G4 -0.447213595499958);// -1 + 4 * G4 // First corner vec4 i = floor(v + dot(v, vec4(F4))); vec4 x0 = v - i + dot(i, C.xxxx); // Other corners // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI) vec4 i0; vec3 isX = step(x0.yzw, x0.xxx); vec3 isYZ = step(x0.zww, x0.yyz); // i0.x = dot( isX, vec3( 1.0 ) ); i0.x = isX.x + isX.y + isX.z; i0.yzw = 1.0 - isX; // i0.y += dot( isYZ.xy, vec2( 1.0 ) ); i0.y += isYZ.x + isYZ.y; i0.zw += 1.0 - isYZ.xy; i0.z += isYZ.z; i0.w += 1.0 - isYZ.z; // i0 now contains the unique values 0,1,2,3 in each channel vec4 i3 = clamp(i0, 0.0, 1.0); vec4 i2 = clamp(i0-1.0, 0.0, 1.0); vec4 i1 = clamp(i0-2.0, 0.0, 1.0); // x0 = x0 - 0.0 + 0.0 * C.xxxx // x1 = x0 - i1 + 1.0 * C.xxxx // x2 = x0 - i2 + 2.0 * C.xxxx // x3 = x0 - i3 + 3.0 * C.xxxx // x4 = x0 - 1.0 + 4.0 * C.xxxx vec4 x1 = x0 - i1 + C.xxxx; vec4 x2 = x0 - i2 + C.yyyy; vec4 x3 = x0 - i3 + C.zzzz; vec4 x4 = x0 + C.wwww; // Permutations i = mod289(i); float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x); vec4 j1 = permute(permute(permute(permute ( i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0)); // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope // 7*7*6 = 294, which is close to the ring size 17*17 = 289. vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0); vec4 p0 = grad4(j0, ip); vec4 p1 = grad4(j1.x, ip); vec4 p2 = grad4(j1.y, ip); vec4 p3 = grad4(j1.z, ip); vec4 p4 = grad4(j1.w, ip); // Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; p4 *= taylorInvSqrt(dot(p4, p4)); // Mix contributions from the five corners vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0); vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0); m0 = m0 * m0; m1 = m1 * m1; return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))); }","title":"snoise(vec4 v)"},{"location":"lib/noise/noisecommon.glsl/","text":"noisecommon.glsl frex:shaders/lib/noise/noisecommon.glsl External MIT noise library - bundled for convenience. Modifications include: + remove the #version header + add this comment block + move some shared functions to this file + use #define for some small functions Preprocessor: #define mod289(x) (x - floor(x * (1.0 / 289.0)) * 289.0) // Modulo 289 without a division (only multiplications) Preprocessor: #define mod7(x) (x - floor(x * (1.0 / 7.0)) * 7.0) // Modulo 7 without a division Preprocessor: #define taylorInvSqrt(r) (1.79284291400159 - 0.85373472095314 * r) permute(vec4 x) Permutation polynomial: (34x^2 + x) mod 289, ring size 289 = 17*17 Can't be defined because used recursively { return mod289((34.0 * x + 1.0) * x); } permute(vec3 x) { return mod289((34.0 * x + 1.0) * x); } permute(float x) { return mod289(((x*34.0)+1.0)*x); }","title":"noisecommon.glsl"},{"location":"lib/noise/noisecommon.glsl/#noisecommonglsl","text":"frex:shaders/lib/noise/noisecommon.glsl External MIT noise library - bundled for convenience. Modifications include: + remove the #version header + add this comment block + move some shared functions to this file + use #define for some small functions","title":"noisecommon.glsl"},{"location":"lib/noise/noisecommon.glsl/#preprocessor-define-mod289x-x-floorx-10-2890-2890-modulo-289-without-a-division-only-multiplications","text":"","title":"Preprocessor: #define mod289(x) (x - floor(x * (1.0 / 289.0)) * 289.0) // Modulo 289 without a division (only multiplications)"},{"location":"lib/noise/noisecommon.glsl/#preprocessor-define-mod7x-x-floorx-10-70-70-modulo-7-without-a-division","text":"","title":"Preprocessor: #define mod7(x) (x - floor(x * (1.0 / 7.0)) * 7.0) // Modulo 7 without a division"},{"location":"lib/noise/noisecommon.glsl/#preprocessor-define-taylorinvsqrtr-179284291400159-085373472095314-r","text":"","title":"Preprocessor: #define taylorInvSqrt(r) (1.79284291400159 - 0.85373472095314 * r)"},{"location":"lib/noise/noisecommon.glsl/#permutevec4-x","text":"Permutation polynomial: (34x^2 + x) mod 289, ring size 289 = 17*17 Can't be defined because used recursively { return mod289((34.0 * x + 1.0) * x); }","title":"permute(vec4 x)"},{"location":"lib/noise/noisecommon.glsl/#permutevec3-x","text":"{ return mod289((34.0 * x + 1.0) * x); }","title":"permute(vec3 x)"},{"location":"lib/noise/noisecommon.glsl/#permutefloat-x","text":"{ return mod289(((x*34.0)+1.0)*x); }","title":"permute(float x)"},{"location":"lib/noise/psrdnoise2d.glsl/","text":"psrdnoise2d.glsl Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl rgrad2(vec2 p, float rot) frex:shaders/lib/noise/psrdnoise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. vec3 psrdnoise(vec2 pos, vec2 per, float rot) vec3 psdnoise(vec2 pos, vec2 per) float psrnoise(vec2 pos, vec2 per, float rot) float psnoise(vec2 pos, vec2 per) vec3 srdnoise(vec2 pos, float rot) vec3 sdnoise(vec2 pos) float srnoise(vec2 pos, float rot) float snoise(vec2 pos) Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise) with rotating gradients and analytic derivatives. Variants also without the derivative (no \"d\" in the name), without the tiling property (no \"p\" in the name) and without the rotating gradients (no \"r\" in the name). This is (yet) another variation on simplex noise. It's similar to the version presented by Ken Perlin, but the grid is axis-aligned and slightly stretched in the y direction to permit rectangular tiling. The noise can be made to tile seamlessly to any integer period in x and any even integer period in y. Odd periods may be specified for y, but then the actual tiling period will be twice that number. The rotating gradients give the appearance of a swirling motion, and can serve a similar purpose for animation as motion along z in 3-D noise. The rotating gradients in conjunction with the analytic derivatives can make \"flow noise\" effects as presented by Perlin and Neyret. vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot}) \"pos\" is the input (x,y) coordinate \"per\" is the x and y period, where per.x is a positive integer and per.y is a positive even integer \"rot\" is the angle to rotate the gradients (any float value, where 0.0 is no rotation and 1.0 is one full turn) The first component of the 3-element return vector is the noise value. The second and third components are the x and y partial derivatives. float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot}) \"pos\" is the input (x,y) coordinate \"per\" is the x and y period, where per.x is a positive integer and per.y is a positive even integer \"rot\" is the angle to rotate the gradients (any float value, where 0.0 is no rotation and 1.0 is one full turn) The return value is the noise value. Partial derivatives are not computed, making these functions faster. Author: Stefan Gustavson (stefan.gustavson@gmail.com) Version 2016-05-10. Many thanks to Ian McEwan of Ashima Arts for the idea of using a permutation polynomial. Copyright (c) 2016 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise TODO: One-pixel wide artefacts used to occur due to precision issues with the gradient indexing. This is specific to this variant of noise, because one axis of the simplex grid is perfectly aligned with the input x axis. The errors were rare, and they are now very unlikely to ever be visible after a quick fix was introduced: a small offset is added to the y coordinate. A proper fix would involve using round() instead of floor() in selected places, but the quick fix works fine. (If you run into problems with this, please let me know.) Hashed 2-D gradients with an extra rotation. (The constant 0.0243902439 is 1/41) { #if 0 // Map from a line to a diamond such that a shift maps to a rotation. float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;// Rotate by shift u = 4.0 * fract(u) - 2.0; // (This vector could be normalized, exactly or approximately.) return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0); #else // For more isotropic gradients, sin/cos can be used instead. float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;// Rotate by shift u = fract(u) * 6.28318530718;// 2*pi return vec2(cos(u), sin(u)); #endif } psrdnoise(vec2 pos, vec2 per, float rot) 2-D tiling simplex noise with rotating gradients and analytical derivative. The first component of the 3-element return vector is the noise value, and the second and third components are the x and y partial derivatives. { // Hack: offset y slightly to hide some rare artifacts pos.y += 0.01; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x); vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y); vec3 iuw = xw + 0.5 * yw; vec3 ivw = yw; // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Partial derivatives for analytical gradient computation vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x); vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y); // Set influence of each surflet to zero outside radius sqrt(0.8) if (t.x < 0.0) { dtdx.x = 0.0; dtdy.x = 0.0; t.x = 0.0; } if (t.y < 0.0) { dtdx.y = 0.0; dtdy.y = 0.0; t.y = 0.0; } if (t.z < 0.0) { dtdx.z = 0.0; dtdy.z = 0.0; t.z = 0.0; } // Fourth power of t (and third power for derivative) vec3 t2 = t * t; vec3 t4 = t2 * t2; vec3 t3 = t2 * t; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Final analytical derivative (gradient of a sum of scalar products) vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x; vec2 dn0 = t4.x * g0 + dt0 * w.x; vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y; vec2 dn1 = t4.y * g1 + dt1 * w.y; vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z; vec2 dn2 = t4.z * g2 + dt2 * w.z; return 11.0*vec3(n, dn0 + dn1 + dn2); } psdnoise(vec2 pos, vec2 per) 2-D tiling simplex noise with fixed gradients and analytical derivative. This function is implemented as a wrapper to \"psrdnoise\", at the minimal cost of three extra additions. { return psrdnoise(pos, per, 0.0); } psrnoise(vec2 pos, vec2 per, float rot) 2-D tiling simplex noise with rotating gradients, but without the analytical derivative. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x); vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y); vec3 iuw = xw + 0.5 * yw; vec3 ivw = yw; // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Set influence of each surflet to zero outside radius sqrt(0.8) t = max(t, 0.0); // Fourth power of t vec3 t2 = t * t; vec3 t4 = t2 * t2; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Rescale to cover the range [-1,1] reasonably well return 11.0*n; } psnoise(vec2 pos, vec2 per) 2-D tiling simplex noise with fixed gradients, without the analytical derivative. This function is implemented as a wrapper to \"psrnoise\", at the minimal cost of three extra additions. { return psrnoise(pos, per, 0.0); } srdnoise(vec2 pos, float rot) 2-D non-tiling simplex noise with rotating gradients and analytical derivative. The first component of the 3-element return vector is the noise value, and the second and third components are the x and y partial derivatives. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; vec3 x = vec3(p0.x, p1.x, p2.x); vec3 y = vec3(p0.y, p1.y, p2.y); vec3 iuw = x + 0.5 * y; vec3 ivw = y; // Avoid precision issues in permutation iuw = mod289(iuw); ivw = mod289(ivw); // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Partial derivatives for analytical gradient computation vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x); vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y); // Set influence of each surflet to zero outside radius sqrt(0.8) if (t.x < 0.0) { dtdx.x = 0.0; dtdy.x = 0.0; t.x = 0.0; } if (t.y < 0.0) { dtdx.y = 0.0; dtdy.y = 0.0; t.y = 0.0; } if (t.z < 0.0) { dtdx.z = 0.0; dtdy.z = 0.0; t.z = 0.0; } // Fourth power of t (and third power for derivative) vec3 t2 = t * t; vec3 t4 = t2 * t2; vec3 t3 = t2 * t; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Final analytical derivative (gradient of a sum of scalar products) vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x; vec2 dn0 = t4.x * g0 + dt0 * w.x; vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y; vec2 dn1 = t4.y * g1 + dt1 * w.y; vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z; vec2 dn2 = t4.z * g2 + dt2 * w.z; return 11.0*vec3(n, dn0 + dn1 + dn2); } sdnoise(vec2 pos) 2-D non-tiling simplex noise with fixed gradients and analytical derivative. This function is implemented as a wrapper to \"srdnoise\", at the minimal cost of three extra additions. { return srdnoise(pos, 0.0); } srnoise(vec2 pos, float rot) 2-D non-tiling simplex noise with rotating gradients, without the analytical derivative. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 x = vec3(p0.x, p1.x, p2.x); vec3 y = vec3(p0.y, p1.y, p2.y); vec3 iuw = x + 0.5 * y; vec3 ivw = y; // Avoid precision issues in permutation iuw = mod289(iuw); ivw = mod289(ivw); // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Set influence of each surflet to zero outside radius sqrt(0.8) t = max(t, 0.0); // Fourth power of t vec3 t2 = t * t; vec3 t4 = t2 * t2; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Rescale to cover the range [-1,1] reasonably well return 11.0*n; } snoise(vec2 pos) 2-D non-tiling simplex noise with fixed gradients, without the analytical derivative. This function is implemented as a wrapper to \"srnoise\", at the minimal cost of three extra additions. Note: if this kind of noise is all you want, there are faster GLSL implementations of non-tiling simplex noise out there. This one is included mainly for completeness and compatibility with the other functions in the file. { return srnoise(pos, 0.0); }","title":"psrdnoise2d.glsl"},{"location":"lib/noise/psrdnoise2d.glsl/#psrdnoise2dglsl","text":"","title":"psrdnoise2d.glsl"},{"location":"lib/noise/psrdnoise2d.glsl/#preprocessor-include-frexshaderslibnoisenoisecommonglsl","text":"","title":"Preprocessor: #include frex:shaders/lib/noise/noisecommon.glsl"},{"location":"lib/noise/psrdnoise2d.glsl/#rgrad2vec2-p-float-rot","text":"frex:shaders/lib/noise/psrdnoise2d.glsl External MIT noise library - bundled for convenience. No modifications have been made except to remove the #version header, add this comment block, and move some shared functions to noisecommon.glsl. vec3 psrdnoise(vec2 pos, vec2 per, float rot) vec3 psdnoise(vec2 pos, vec2 per) float psrnoise(vec2 pos, vec2 per, float rot) float psnoise(vec2 pos, vec2 per) vec3 srdnoise(vec2 pos, float rot) vec3 sdnoise(vec2 pos) float srnoise(vec2 pos, float rot) float snoise(vec2 pos) Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise) with rotating gradients and analytic derivatives. Variants also without the derivative (no \"d\" in the name), without the tiling property (no \"p\" in the name) and without the rotating gradients (no \"r\" in the name). This is (yet) another variation on simplex noise. It's similar to the version presented by Ken Perlin, but the grid is axis-aligned and slightly stretched in the y direction to permit rectangular tiling. The noise can be made to tile seamlessly to any integer period in x and any even integer period in y. Odd periods may be specified for y, but then the actual tiling period will be twice that number. The rotating gradients give the appearance of a swirling motion, and can serve a similar purpose for animation as motion along z in 3-D noise. The rotating gradients in conjunction with the analytic derivatives can make \"flow noise\" effects as presented by Perlin and Neyret. vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot}) \"pos\" is the input (x,y) coordinate \"per\" is the x and y period, where per.x is a positive integer and per.y is a positive even integer \"rot\" is the angle to rotate the gradients (any float value, where 0.0 is no rotation and 1.0 is one full turn) The first component of the 3-element return vector is the noise value. The second and third components are the x and y partial derivatives. float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot}) \"pos\" is the input (x,y) coordinate \"per\" is the x and y period, where per.x is a positive integer and per.y is a positive even integer \"rot\" is the angle to rotate the gradients (any float value, where 0.0 is no rotation and 1.0 is one full turn) The return value is the noise value. Partial derivatives are not computed, making these functions faster. Author: Stefan Gustavson (stefan.gustavson@gmail.com) Version 2016-05-10. Many thanks to Ian McEwan of Ashima Arts for the idea of using a permutation polynomial. Copyright (c) 2016 Stefan Gustavson. All rights reserved. Distributed under the MIT license. See LICENSE file. https://github.com/stegu/webgl-noise TODO: One-pixel wide artefacts used to occur due to precision issues with the gradient indexing. This is specific to this variant of noise, because one axis of the simplex grid is perfectly aligned with the input x axis. The errors were rare, and they are now very unlikely to ever be visible after a quick fix was introduced: a small offset is added to the y coordinate. A proper fix would involve using round() instead of floor() in selected places, but the quick fix works fine. (If you run into problems with this, please let me know.) Hashed 2-D gradients with an extra rotation. (The constant 0.0243902439 is 1/41) { #if 0 // Map from a line to a diamond such that a shift maps to a rotation. float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;// Rotate by shift u = 4.0 * fract(u) - 2.0; // (This vector could be normalized, exactly or approximately.) return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0); #else // For more isotropic gradients, sin/cos can be used instead. float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;// Rotate by shift u = fract(u) * 6.28318530718;// 2*pi return vec2(cos(u), sin(u)); #endif }","title":"rgrad2(vec2 p, float rot)"},{"location":"lib/noise/psrdnoise2d.glsl/#psrdnoisevec2-pos-vec2-per-float-rot","text":"2-D tiling simplex noise with rotating gradients and analytical derivative. The first component of the 3-element return vector is the noise value, and the second and third components are the x and y partial derivatives. { // Hack: offset y slightly to hide some rare artifacts pos.y += 0.01; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x); vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y); vec3 iuw = xw + 0.5 * yw; vec3 ivw = yw; // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Partial derivatives for analytical gradient computation vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x); vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y); // Set influence of each surflet to zero outside radius sqrt(0.8) if (t.x < 0.0) { dtdx.x = 0.0; dtdy.x = 0.0; t.x = 0.0; } if (t.y < 0.0) { dtdx.y = 0.0; dtdy.y = 0.0; t.y = 0.0; } if (t.z < 0.0) { dtdx.z = 0.0; dtdy.z = 0.0; t.z = 0.0; } // Fourth power of t (and third power for derivative) vec3 t2 = t * t; vec3 t4 = t2 * t2; vec3 t3 = t2 * t; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Final analytical derivative (gradient of a sum of scalar products) vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x; vec2 dn0 = t4.x * g0 + dt0 * w.x; vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y; vec2 dn1 = t4.y * g1 + dt1 * w.y; vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z; vec2 dn2 = t4.z * g2 + dt2 * w.z; return 11.0*vec3(n, dn0 + dn1 + dn2); }","title":"psrdnoise(vec2 pos, vec2 per, float rot)"},{"location":"lib/noise/psrdnoise2d.glsl/#psdnoisevec2-pos-vec2-per","text":"2-D tiling simplex noise with fixed gradients and analytical derivative. This function is implemented as a wrapper to \"psrdnoise\", at the minimal cost of three extra additions. { return psrdnoise(pos, per, 0.0); }","title":"psdnoise(vec2 pos, vec2 per)"},{"location":"lib/noise/psrdnoise2d.glsl/#psrnoisevec2-pos-vec2-per-float-rot","text":"2-D tiling simplex noise with rotating gradients, but without the analytical derivative. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x); vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y); vec3 iuw = xw + 0.5 * yw; vec3 ivw = yw; // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Set influence of each surflet to zero outside radius sqrt(0.8) t = max(t, 0.0); // Fourth power of t vec3 t2 = t * t; vec3 t4 = t2 * t2; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Rescale to cover the range [-1,1] reasonably well return 11.0*n; }","title":"psrnoise(vec2 pos, vec2 per, float rot)"},{"location":"lib/noise/psrdnoise2d.glsl/#psnoisevec2-pos-vec2-per","text":"2-D tiling simplex noise with fixed gradients, without the analytical derivative. This function is implemented as a wrapper to \"psrnoise\", at the minimal cost of three extra additions. { return psrnoise(pos, per, 0.0); }","title":"psnoise(vec2 pos, vec2 per)"},{"location":"lib/noise/psrdnoise2d.glsl/#srdnoisevec2-pos-float-rot","text":"2-D non-tiling simplex noise with rotating gradients and analytical derivative. The first component of the 3-element return vector is the noise value, and the second and third components are the x and y partial derivatives. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; vec3 x = vec3(p0.x, p1.x, p2.x); vec3 y = vec3(p0.y, p1.y, p2.y); vec3 iuw = x + 0.5 * y; vec3 ivw = y; // Avoid precision issues in permutation iuw = mod289(iuw); ivw = mod289(ivw); // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Partial derivatives for analytical gradient computation vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x); vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y); // Set influence of each surflet to zero outside radius sqrt(0.8) if (t.x < 0.0) { dtdx.x = 0.0; dtdy.x = 0.0; t.x = 0.0; } if (t.y < 0.0) { dtdx.y = 0.0; dtdy.y = 0.0; t.y = 0.0; } if (t.z < 0.0) { dtdx.z = 0.0; dtdy.z = 0.0; t.z = 0.0; } // Fourth power of t (and third power for derivative) vec3 t2 = t * t; vec3 t4 = t2 * t2; vec3 t3 = t2 * t; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Final analytical derivative (gradient of a sum of scalar products) vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x; vec2 dn0 = t4.x * g0 + dt0 * w.x; vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y; vec2 dn1 = t4.y * g1 + dt1 * w.y; vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z; vec2 dn2 = t4.z * g2 + dt2 * w.z; return 11.0*vec3(n, dn0 + dn1 + dn2); }","title":"srdnoise(vec2 pos, float rot)"},{"location":"lib/noise/psrdnoise2d.glsl/#sdnoisevec2-pos","text":"2-D non-tiling simplex noise with fixed gradients and analytical derivative. This function is implemented as a wrapper to \"srdnoise\", at the minimal cost of three extra additions. { return srdnoise(pos, 0.0); }","title":"sdnoise(vec2 pos)"},{"location":"lib/noise/psrdnoise2d.glsl/#srnoisevec2-pos-float-rot","text":"2-D non-tiling simplex noise with rotating gradients, without the analytical derivative. { // Offset y slightly to hide some rare artifacts pos.y += 0.001; // Skew to hexagonal grid vec2 uv = vec2(pos.x + pos.y*0.5, pos.y); vec2 i0 = floor(uv); vec2 f0 = fract(uv); // Traversal order vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // Unskewed grid points in (x,y) space vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y); vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y); vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0); // Integer grid point indices in (u,v) space i1 = i0 + i1; vec2 i2 = i0 + vec2(1.0, 1.0); // Vectors in unskewed (x,y) coordinates from // each of the simplex corners to the evaluation point vec2 d0 = pos - p0; vec2 d1 = pos - p1; vec2 d2 = pos - p2; // Wrap i0, i1 and i2 to the desired period before gradient hashing: // wrap points in (x,y), map to (u,v) vec3 x = vec3(p0.x, p1.x, p2.x); vec3 y = vec3(p0.y, p1.y, p2.y); vec3 iuw = x + 0.5 * y; vec3 ivw = y; // Avoid precision issues in permutation iuw = mod289(iuw); ivw = mod289(ivw); // Create gradients from indices vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot); vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot); vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot); // Gradients dot vectors to corresponding corners // (The derivatives of this are simply the gradients) vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2)); // Radial weights from corners // 0.8 is the square of 2/sqrt(5), the distance from // a grid point to the nearest simplex boundary vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2)); // Set influence of each surflet to zero outside radius sqrt(0.8) t = max(t, 0.0); // Fourth power of t vec3 t2 = t * t; vec3 t4 = t2 * t2; // Final noise value is: // sum of ((radial weights) times (gradient dot vector from corner)) float n = dot(t4, w); // Rescale to cover the range [-1,1] reasonably well return 11.0*n; }","title":"srnoise(vec2 pos, float rot)"},{"location":"lib/noise/psrdnoise2d.glsl/#snoisevec2-pos","text":"2-D non-tiling simplex noise with fixed gradients, without the analytical derivative. This function is implemented as a wrapper to \"srnoise\", at the minimal cost of three extra additions. Note: if this kind of noise is all you want, there are faster GLSL implementations of non-tiling simplex noise out there. This one is included mainly for completeness and compatibility with the other functions in the file. { return srnoise(pos, 0.0); }","title":"snoise(vec2 pos)"},{"location":"material/default.frag/","text":"default.frag Preprocessor: #include frex:shaders/api/fragment.glsl frx_materialFragment() frex:shaders/material/default.frag { // NOOP }","title":"default.frag"},{"location":"material/default.frag/#defaultfrag","text":"","title":"default.frag"},{"location":"material/default.frag/#preprocessor-include-frexshadersapifragmentglsl","text":"","title":"Preprocessor: #include frex:shaders/api/fragment.glsl"},{"location":"material/default.frag/#frx_materialfragment","text":"frex:shaders/material/default.frag { // NOOP }","title":"frx_materialFragment()"},{"location":"material/default.vert/","text":"default.vert Preprocessor: #include frex:shaders/api/vertex.glsl frx_materialVertex() frex:shaders/material/default.vert { // NOOP }","title":"default.vert"},{"location":"material/default.vert/#defaultvert","text":"","title":"default.vert"},{"location":"material/default.vert/#preprocessor-include-frexshadersapivertexglsl","text":"","title":"Preprocessor: #include frex:shaders/api/vertex.glsl"},{"location":"material/default.vert/#frx_materialvertex","text":"frex:shaders/material/default.vert { // NOOP }","title":"frx_materialVertex()"}]}